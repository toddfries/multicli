#!/usr/bin/perl

# Copyright (c) 2017,2018 Todd T. Fries <todd@fries.net>
#
# Permission to use, copy, modify, and distribute this software for any
# purpose with or without fee is hereby granted, provided that the above
# copyright notice and this permission notice appear in all copies.
#
# THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
# WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
# MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
# ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
# WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
# ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
# OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.

use strict;
use warnings;

use Config::Tiny;
use Date::Manip;
use Date::Manip::Date;
use Getopt::Std;
use Data::Dumper;
use POSIX qw(strftime);
use ReadConf;

STDERR->autoflush(1);
STDOUT->autoflush(1);

our $opt_a;
our $opt_p;
our $opt_q = 0;
our $opt_t;    # bci/rawtx txid
our $opt_v = 0;
our $opt_c; # config file, if desired to over-ride
our $opt_H; # weather historic date

our $opt_C; # hetzner min cpu
our $opt_D; # hetzner min disk
our $opt_M; # hetzner min mem

getopt('a:c:p:q:t:vC:D:H:M:');

if (!defined($opt_p)) {
	$opt_p = "all";
}

our $mcli = { };
our $stats = { };

our $r = ReadConf->new();

foreach my $p (split(/,/,$opt_p)) {
if ($p eq "all") {
	hetzner();
	namecheap();
	voipms();
	c1360();
}

if ($p eq "hetzner") {
	hetzner();
}

if ($p eq "namecheap") {
	namecheap();
}

if ($p eq "voipms") {
	voipms();
}

if ($p eq "c1360") {
	c1360();
}

if ($p eq "coinbase") {
	coinbase();
}

if ($p eq "kraken") {
	kraken();
}
if ($p eq "bitstamp") {
	bitstamp();
}
if ($p eq "bci") {
	bci();
}
if ($p eq "bw") {
	bw();
}
if ($p eq "bleutrade") {
	bleutrade();
}
if ($p eq "btexch") {
	btexch();
}
if ($p eq "btcusd") {
	btcusd();
}
if ($p eq "dcrbtc") {
	dcrbtc();
}

if ($p eq "weather") {
	weather();
}
}

if (0) {
use Finance::BlockIO;

my $ret = Finance::BlockIO->get_current_price;
print "BlockIO price ret: ",$ret,"\n";
}

1;

sub status {
	my ($str) = @_;
	if ($opt_q > 0) {
		return;
	}

	print "\n==> $str status\n";
}

sub hetzner {

	if (!defined($mcli->{hetzner})) {
		$mcli->{hetzner} = hetzner_setup();
	}
	my $hetzner = $mcli->{hetzner};

	status("Hetzner server");

	my @hservers = $hetzner->servers;
	printf "%7s %12s %10s %10s %14s %s\n", "Number","Name","Paid Till","Cancel Date","IP","Traffic";
	foreach my $s (@hservers) {
		my ($ti,$to,$ts) = $s->traffic;
		if (!defined($ts)) {
			$ts = 0.0;
		}
		my $cancel = $s->cancel;
		my $ed = "";
		if (defined($cancel)) {
			$ed = $cancel->get('earliest_cancellation_date');
		}
		printf "%7d %12s %10s %10s %15s %f\n",
			$s->get('server_number'),
			$s->get('server_name'),
			$s->get('paid_until'),
			$ed,
			$s->get('server_ip'),
			$ts;
	}

	status("Server Market");
	my $call = "order/server_market/product";
	$call .= "?search=Ent";

	# min_cpu_benchmark
	# cpu    bench
	# i7-920 5005
	# i7-930 5165
	# i7-950 5682
	# i7-960 6012
	# i7-975 6370
	# AMD Opteron 6338P 6853
	my $winner;
	if (!defined($opt_D)) {
		$opt_D = 0;
	}
	my $servers = { };
	$servers->{px}->{minmem} = 47;
	$servers->{px}->{mincpu} = 5681;
	$servers->{px}->{mindisk} = 2048;

	$servers->{pxupgrade}->{minmem} = 47;
	$servers->{pxupgrade}->{mincpu} = 5683;
	$servers->{pxupgrade}->{mindisk} = 2048;

	$servers->{st}->{minmem} = 7;
	$servers->{st}->{mincpu} = 999;
	$servers->{st}->{mindisk} = 8191;

	$servers->{bst}->{minmem} = 3;
	$servers->{bst}->{mincpu} = 1;
	$servers->{bst}->{mindisk} = 16383;

	$servers->{mem64}->{minmem} = 63;
	$servers->{mem64}->{mincpu} = 1;
	$servers->{mem64}->{mindisk} = 0;

	$servers->{mem128}->{minmem} = 127;
	$servers->{mem128}->{mincpu} = 1;
	$servers->{mem128}->{mindisk} = 0;

	if (defined($opt_D)||defined($opt_C)||defined($opt_M)) {
		$servers->{cli}->{minmem} = 1;
		$servers->{cli}->{mincpu} = 1;
		$servers->{cli}->{mindisk} = 1;
		if (defined($opt_D)) {
			$servers->{cli}->{mindisk} = $opt_D;
		}
		if (defined($opt_M)) {
			$servers->{cli}->{minmem} = $opt_M;
		}
		if (defined($opt_C)) {
			$servers->{cli}->{mincpu} = $opt_C;
		}
	}

	my $mins = { };

	foreach my $name (keys %{$servers}) {
		foreach my $mn (('minmem', 'mincpu', 'mindisk')) {
			if (!defined($mins->{$mn})) {
				$mins->{$mn} = $servers->{$name}->{$mn};
				next;
			}
			if ($mins->{$mn} > $servers->{$name}->{$mn}) {
				$mins->{$mn} = $servers->{$name}->{$mn};
			}
		}
	}

	$call .= "&min_cpu_benchmark=".$mins->{mincpu};
	$call .= "&min_memory_size=".$mins->{minmem};
	my $parsed = $hetzner->get($call);

	my $scount=0;

	# XXX make this a sort, and print up to X servers
	foreach my $server ( @{$parsed} ) {
		if ($scount++ < 1 && $opt_v > 0) {
			print Dumper($server);
		}
		my $sp = $server->{product};
		my $disk =  $sp->{hdd_count} * $sp->{hdd_size};
		if ($disk < $opt_D) {
			next;
		}
		foreach my $name (keys %{$servers}) {
			my $s = $servers->{$name};
			if ($s->{minmem} > $sp->{memory_size}) {
				next;
			}
			if ($s->{mincpu} > $sp->{cpu_benchmark}) {
				next;
			}
			if ($s->{mindisk} > ($sp->{hdd_count} * $sp->{hdd_size})) {
				next;
			}
			if (!defined($s->{winner})) {
				$s->{winner} = $server;
				next;
			}
			my $wp = $s->{winner}->{product};
			if ($sp->{price} < $wp->{price}) {
				next;
			}
			if ($sp->{price} == $wp->{price}) {
				if ($sp->{memory_size} > $wp->{memory_size}) {
					$s->{winner} = $server;
					next;
				}
				my $wd = $wp->{hdd_count} * $wp->{hdd_size};
				if ($disk > $wd) {
					$s->{winner} = $server;
					next;
				}
				if ($sp->{cpu_benchmark} > $wp->{cpu_benchmark}) {
					$s->{winner} = $server;
					next;
				}
			}
		}
	}

	foreach my $name (keys %{$servers}) {
		my $wp = $servers->{$name}->{winner}->{product};
		rank_length('EUR', sprintf("%0.2f", $wp->{price}));
		rank_length('name', $wp->{name});
		rank_length('myname', $name);
	}
	my $eulen = get_length('EUR');
	my $namlen = get_length('name');
	my $mynamlen = get_length('myname');
	printf "%7s  %${namlen}s %3s %6s %5s %${eulen}s (min cpu disk   ram %${mynamlen}s)\n",
	    "PID", "Name", "RAM", "disk", "total", "EUR", 'name';
	foreach my $name (keys %{$servers}) {
		my $wp = $servers->{$name}->{winner}->{product};
		printf "%7s. %${namlen}s %3d %dx%4d=%5d %${eulen}.2f (%5d %5d %6d %${mynamlen}s)\n", $wp->{id}, $wp->{name},
		    $wp->{memory_size}, $wp->{hdd_count}, $wp->{hdd_size},
		    $wp->{hdd_count} * $wp->{hdd_size},
		    $wp->{price},
		    $servers->{$name}->{mincpu},
		    $servers->{$name}->{mindisk},
		    $servers->{$name}->{minmem},
		    $name;
	}
}

sub hetzner_setup {
	use WWW::Hetzner;

	my $hconfig = $r->readconf($ENV{'HOME'}."/.hcli.conf")->{_};

	my $hetzner = WWW::Hetzner->new(
		huser => $hconfig->{huser},
		hpass => $hconfig->{hpass},
	);
	return $hetzner;
}

sub coinbase {
	if (!defined($mcli->{coinbase})) {
		$mcli->{coinbase} = coinbase_setup();
	}
	my $coinbase = $mcli->{coinbase};

	status("Coinbase spot price");

	my ($res) = $coinbase->get_spot_price("USD");
	my $price = $res->{data}->{amount};
	if ($opt_q > 0) {
		print $price;
		return;
	}
	printf "Current bitcoin price in %s: %s\n", "USD", $price;

	my @resp = $coinbase->get_accounts();
	my @accts;
	foreach my $parsed (@resp) {
		if (defined($parsed->{data})) {
			foreach my $k ($parsed->{data}) {
				if (ref($k) eq "ARRAY") {
					foreach my $l (@{$k}) {
						push @accts,$l;
					}
				}
			}
		}
	}
	my $totalusd=0.0;
	foreach my $a (@accts) {
		$totalusd += $a->{native_balance}->{amount};
	}
	my $totalbtc=$totalusd/$price;
	printf "Total in coinbase wallets: %10.8f BTC (%8.3f USD)\n",
		$totalbtc, $totalusd;
}

sub bleutrade_setup {
	use WebService::BleuTrade;
	use LWP::UserAgent;

	my $conf = $ENV{'HOME'}."/.bleutrade.conf";
	my $config = $r->readconf($conf)->{_};
	my $key = $config->{key};
	my $ro = $config->{ro};

	my $ua = LWP::UserAgent->new;
	$ua->agent("mcli/0.0 ".$ua->agent);
	$ua->agent("OpenBSD ftp");
	$ua->agent("Mozilla/4.0 (compatible; Bleutrade API perl client)");
	$ua->env_proxy(1);

	my $bt;
	if (defined($key) && defined($ro)) {
		$bt = WebService::BleuTrade->new(
		    ua => $ua,
		    api_key => $key,
		    api_secret => $ro,
		);
	} else {
		$bt = WebService::BleuTrade->new(ua => $ua);
	}
	return $bt;
}

sub coinbase_setup {
	use WebService::CoinBase::v2;

	my @scopes = (
        	"wallet:accounts:read",
        	"wallet:checkouts:read",
        	"wallet:checkouts:create",
        	#"wallet:orders:read",
        	#"wallet:orders:create",
        	"wallet:transactions:read",
        	"wallet:user:read",
	);

	my $scope = "";
	foreach my $s (@scopes) {
        	if (defined($scope)) {
                	$scope .= ",".$s;
        	} else {
                	$scope = $s;
        	}
	}
	my $coinbase = WebService::CoinBase::v2->new(
		scopes => $scope,
	);
	return $coinbase;
}

sub coinbase_order_accts {
	my $res;
	$res = $a->{type} cmp $b->{type};
	if ($res != 0) {
		return $res*-1;
	}
	$res = $a->{currency} cmp $b->{currency};
	if ($res != 0) {
		return $res;
	}
	return $a->{name} cmp $b->{name};
}

sub kraken {
	use Finance::Bank::Kraken;
	if (!defined($mcli->{kraken})) {
		$mcli->{kraken} = kraken_setup();
	}
	my $kraken = $mcli->{kraken};

	if (!defined($opt_a)) {
		$opt_a = "ticker";
	}

	if ($opt_a eq "ticker") {

		status("Kraken spot price");

		my $res = $kraken->call(Public, 'Ticker', ['pair=XBTUSD']);
		my $parsed = parse_json( $res, 'kraken' );

		#print Dumper($parsed);
		my $btc = $parsed->{result}->{XXBTZUSD};
		if (!defined($btc)) {
			print "Oops, btc not found\n";
			return;
		}
		my $bid = $btc->{b}[0];
		my $ask = $btc->{a}[0];
		my $avg = ($bid+$ask)/2;
		if ($opt_q > 0) {
			print $avg;
			return;
		}
		printf "Bid %s\nAsk %s\n", $bid, $ask;
		printf "Avg %s\n", $avg;
		printf "Low %s %s (today 24hrs)\n", $btc->{l}[0], $btc->{l}[1];
		printf "Hi  %s %s (today 24hrs)\n", $btc->{h}[0], $btc->{h}[1];
		printf "Vol %s %s (today 24hrs)\n", $btc->{v}[0], $btc->{v}[1];
		printf "Wav %s %s (today 24hrs)\n", $btc->{p}[0], $btc->{p}[1];
		printf "Lst %s %s (price volume)\n", $btc->{c}[0], $btc->{c}[1];
	}
	if ($opt_a eq "assets") {
		my $res = $kraken->call(Public, 'Assets');
		my $parsed = parse_json( $res, 'kraken' );
		foreach my $asset (sort keys %{$parsed->{result}}) {
			my $r = $parsed->{result}->{$asset};
			printf "%4s %4s %8s %2d %2d\n", $asset, $r->{altname},
			    $r->{aclass}, $r->{decimals},
			    $r->{display_decimals};
		}
		#print Dumper($parsed);
	}
	if ($opt_a eq "assetpairs") {
		my $res = $kraken->call(Public, 'AssetPairs');
		my $parsed = parse_json( $res, 'kraken' );
		foreach my $pair (sort keys %{$parsed->{result}}) {
			my $r = $parsed->{result}->{$pair};
			printf "%11s %11s %8s %4s %4s\n", $pair, $r->{altname},
			    $r->{aclass_base}, $r->{base}, $r->{quote};
		}
		#print Dumper($parsed);
	}
		
}

sub kraken_setup {
	use Finance::Bank::Kraken;
	use JSON;
	if (!defined($mcli->{JSON})) {
		$mcli->{JSON} = JSON->new->allow_nonref;
	}

	my $kraken = Finance::Bank::Kraken->new;
	return $kraken;
}

sub bitstamp {
	#use Finance::BitStamp::API;
	if (!defined($mcli->{bitstamp})) {
		$mcli->{bitstamp} = bitstamp_setup();
	}
	my $bitstamp = $mcli->{bitstamp};

	status("BitStamp spot price");

	my $res = $bitstamp->ticker;
	#print Dumper($res);
	#my $parsed = parse_json( $res, 'kraken' );

	#print Dumper($parsed);
	my $bid = $res->{bid};
	my $ask = $res->{ask};
	my $avg = ($bid+$ask)/2;
	if ($opt_q > 0) {
		print $avg;
		return;
	}
	printf "Bid %s\nAsk %s\n", $bid, $ask;
	printf "Avg %s\n", $avg;
	printf "Low %s\n", $res->{low};
	printf "Hi  %s\n", $res->{high};
	printf "Vol %s\n", $res->{volume};
}

sub bitstamp_setup {
	use Finance::BitStamp::API;
	use JSON;
	if (!defined($mcli->{JSON})) {
		$mcli->{JSON} = JSON->new->allow_nonref;
	}

	my $bitstamp = Finance::BitStamp::API->new;
	return $bitstamp;
}

sub bci {
	if (!defined($mcli->{bci})) {
		$mcli->{bci} = bci_setup();
	}
	my $bci = $mcli->{bci};
	$bci->ua->agent("OpenBSD ftp");

	if (defined($opt_a) && $opt_a eq "rawtx" && defined($opt_t)) {
		my $rawtx = $bci->rawtx($opt_t);
		print Dumper($rawtx);
		return;
	}
		
	status("BlockChain.info lastblock");

	my $res = $bci->latestblock;

	my $hash = $res->{hash};
	my @txi = @{$res->{txIndexes}};
	my $block_index = $res->{block_index};
	my $time = $res->{time};
	my $height = $res->{height};
	if ($opt_q > 0) {
		print $height;
		return;
	}
	printf "%s %d %s\n", strftime("%Y%m%d %H:%M:%S",localtime($time)),
	    $height, $hash;
}

sub bci_setup {
	use WebService::BlockChain::Info;
	use JSON;
	if (!defined($mcli->{JSON})) {
		$mcli->{JSON} = JSON->new->allow_nonref;
	}

	my $bci = WebService::BlockChain::Info->new;
	return $bci;
}
sub bw {
	if (!defined($mcli->{bw})) {
		$mcli->{bw} = bw_setup();
	}
	my $bw = $mcli->{bw};
	$bw->ua->agent("OpenBSD ftp");

	status("bw.com account info");

	my $res = $bw->account;
	print Dumper($res);
}

sub bw_setup {
	use WebService::BW;
	use JSON;
	if (!defined($mcli->{JSON})) {
		$mcli->{JSON} = JSON->new->allow_nonref;
	}

	my $conf = $ENV{'HOME'}."/.bw.conf";
	my $config = $r->readconf($conf)->{_};
	my $key = $config->{key};
	my $sec = $config->{sec};
	my $user = $config->{user};

	my $bw = WebService::BW->new( api_key => $key, api_secret => $sec,
		userName => $user );

	return $bw;
}

sub namecheap {
	if (!defined($mcli->{namecheap})) {
		$mcli->{namecheap} = namecheap_setup();
	}
	my $namecheap = $mcli->{namecheap};

	status("Namecheap domain");

	my $dns = $namecheap->dns();
	my $domlist = $dns->getdomains();

	foreach my $dd (@{$domlist->{Domain}}) {
		$dd->{ExpiresUD} = UnixDate(ParseDate($dd->{Expires}),"%s");
	}

	foreach my $dd (sort { $a->{ExpiresUD} <=> $b->{ExpiresUD} } @{$domlist->{Domain}}) {
		my %d = %{$dd};
		my $dom = $d{'Name'};
		printf STDERR "%9d %10s %s\n", $d{'ID'}, $d{'Expires'}, $d{'Name'};
	}
}

sub namecheap_setup {
	my $namecheap;

	use WWW::Namecheap::API;

	my $nconf = $ENV{'HOME'}."/.namecheap.conf";
	my $nconfig = $r->readconf($nconf)->{_};

	my $napiuser=$nconfig->{'apiuser'};
	my $napikey=$nconfig->{'apikey'};

	if (!defined($napiuser) || !defined($napikey)) {
		die "napiuser and napikey must be defined in the config file: $nconf";
	}

	$namecheap = WWW::Namecheap::API->new(
		#System => 'test',
		System => 'prod',
		ApiUser => $napiuser,
		ApiKey => $napikey,
		DefaultIp => $nconfig->{'defaultip'},
	);
	return $namecheap;
}

sub weather_timefmt {
	my ($str) = @_;
	if (!defined($str)) {
		return "<str:undef>";
	}
	my $date = Date::Manip::Date->new();
	if ($str =~ /^([0-9]+:[0-9]+ [AP]M) ([A-Z]+) on (.*)$/) {
		$date->parse_date($3);
		$date->parse_time($1);
		return $date->printf("%Y%m%d %H:%M:%S");
		$str = "$3 $1";
	}
	$date->parse($str);
	return $date->printf("%Y%m%d %H:%M:%S");
}

sub weather_history {
	my ($weather, $date) = @_;

	my $history = $weather->api_call("history_${date}");
	my $sum = $history->{dailysummary};
	foreach my $e (@$sum) {
		printf "%s %3d/%3d\n",
		    weather_timefmt($history->{date}{pretty}),
		    $$e{maxtempi}, $$e{mintempi};
	}
	#      20170829 18:53:00 81.00  29.97 10.4  44% 0 0 0 Remarks
	print "  Date     Time   Temp   Press wspd  hum rain/hail/snow Remarks\n";
	foreach my $o (@{$history->{observations}}) {
		my $w = { };
		foreach my $wt (("rain","snow","hail")) {
			if (!defined($$o{$wt})) {
				$w->{$wt} = 0;
				next;
			}
			if ($$o{$wt} eq "N/A") {
				$w->{$wt} = 0;
				next;
			}
			$w->{$wt} = $$o{$wt};
		}
		$w->{fmt}->{tempi}->{std} = "%4.2f";
		$w->{fmt}->{tempi}->{na} = "%5s";
		$w->{fmt}->{hum}->{std} = "%3d%%";
		$w->{fmt}->{hum}->{na} = "%4s";
		my $na = 'n/a';
		foreach my $wt (("tempi","hum")) {
			if (!defined($$o{$wt})) {
				$w->{$wt} = sprintf $w->{fmt}->{$wt}->{na},$na;
				next;
			}
			if ($$o{$wt} =~ /n\/a/i) {
				$w->{$wt} = sprintf $w->{fmt}->{$wt}->{na},$na;
				next;
			}
			if ($$o{$wt} == -9999.0) {
				$w->{$wt} = sprintf $w->{fmt}->{$wt}->{na},$na;
				next;
			}
			$w->{$wt} = sprintf $w->{fmt}->{$wt}->{std}, $$o{$wt};
		}
		my $metar = $$o{metar};
		my $rmk;
		if ($metar =~ /.* RMK (.*)$/) {
			$rmk = $1;
		} else {
			$rmk = "";
		}
		printf "%s %5s %6.2f %4.1f %4s %s %s %s %s\n",
		    weather_timefmt($$o{date}{pretty}),
		    $w->{tempi}, $$o{pressurei}, $$o{wspdi}, $w->{hum},
		    $w->{rain}, $w->{hail}, $w->{snow}, $rmk;
		#if ($$o{tempi} == -9999.00) {
		#	print Dumper($o);
		#}
	}
	#print Dumper($history);
	return;
}

sub weather {
	if (!defined($mcli->{weather})) {
		$mcli->{weather} = weather_setup();
	}
	#use Temperature::Windchill qw{ windchill_us };

	my $weather = $mcli->{weather};

	if (defined($opt_H)) {
		weather_history($weather, $opt_H);
		return;
	}
	
	my $astro = $weather->astronomy;
	my $times = { };
	if (defined($astro)) {
		foreach my $sm (("sun","moon")) {
			foreach my $rs (("rise","set")) {
				my $time;
				my $op = ${sm}.${rs};
				eval {
			    		$time = $astro->$op;
				};
				if ($@) {
					print "Hmm: $@\n";
				}
				if (defined($time)) {
					$times->{$sm}->{$rs} =
					    sprintf("%02d:%02d",
					    $time->hour, $time->minute);
				} else {
					$times->{$sm}->{$rs} = "undef";
				}
			}
		}

		printf("Sun/Moon rise->set %s->%s / %s->%s\n",
			$times->{sun}->{rise}, $times->{sun}->{set},
			$times->{moon}->{rise}, $times->{moon}->{set},
		);
	} else {
		printf "astro %s { sunrise = %s, sunset = %s, moonrise = %s, ".
		    "moonset = %s}\n", $astro, $astro->sunrise, $astro->sunset,
		    $astro->moonrise, $astro->moonset;
	}

	my $forecast = $weather->forecast;
	#print Dumper($forecast);

	printf("Temp(F) %4.1f :", $weather->temp_f);
	my @hourly = @{ $weather->hourly };
	my $lines = weather_init_lines();
	$lines->{topline} = "";
	my $hcount = 0;
	my $lastr;
	foreach my $r (@hourly) {
		$lines->{topline} .= sprintf(" %3d", $r->{FCTTIME}{hour_padded});
		$lines->{infline} .= sprintf(" %3d", $r->{temp}{english});
		my $wch = $r->{windchill}{english};
		if ($wch == -9999) {
			$wch = $r->{feelslike}{english};
			if ($wch == -9999) {
				$wch = $r->{heatindex}{english};
			}
		}
		$lines->{feeline} .= sprintf(" %3d", $wch);
		$lines->{spdline} .= sprintf(" %3d", $r->{wspd}{english});
		$lines->{humline} .= sprintf(" %3d", $r->{humidity});
		$lines->{qpfline} .= sprintf(" %3.1f", $r->{qpf}{english});
		if ($hcount++ > 11) {
			$hcount = 0;
			print $lines->{topline}."\n";
			print $lines->{infline}."\n";
			print $lines->{spdline}."\n";
			print $lines->{feeline}."\n";
			print $lines->{humline}."\n";
			print $lines->{qpfline}."\n";
			print "\n";
			$lines = weather_init_lines();
		}
		$lastr = $r;
	}
	print "\n";
	#print Dumper($lastr);

	my $forecast10 = $weather->forecast10day;
	my $lastday;
	#print Dumper($forecast10);
	#     "Jan 16, 2018   17/   6 15/ 9    5/ -11  41    0  0.00 Clear";
	print "                Temp    Wind  RealFeel      POP  Rain\n";
	print "    Date       Hi/  Lo Hi/Lo   Hi/ Lo Humid.  %  (in) Conditions\n";
	foreach my $day (@{$forecast10->{simpleforecast}->{forecastday}}) {
		my $maxwind = $day->{maxwind}->{mph};
		my $avgwind = $day->{avewind}->{mph};
		my $lowwind = ( $avgwind * 2 ) - $maxwind;
		my $high = $day->{high}->{fahrenheit};
		my $low = $day->{low}->{fahrenheit};
		my $wchi = windchill_us( $high, $lowwind );
		my $wclo = windchill_us( $low, $maxwind );
		printf "%3s %2s, %4s %4d/%4d %2d/%2d %4d/%4d %3d %4i %5.2f %-s\n",
			$day->{date}->{monthname_short},
			$day->{date}->{day},
			$day->{date}->{year},
			$high, $low,
			$maxwind, $lowwind,
			$wchi, $wclo,
			$day->{avehumidity},
			$day->{pop},
			$day->{qpf_allday}{in},
			$day->{conditions};
		$lastday = $day;
		#print Dumper($lastday);
	}
	#print Dumper($lastday);
	#print Dumper($weather->data);
}

sub windchill_us {
	my ($temp, $ws) = @_;
	if (!defined($temp) || !defined($ws)) {
		return $temp;
	}
	if ($ws < 3) {
		return $temp;
	}
	if ($temp > 50 || $temp < -50) {
		return $temp;
	}
	my $pow = $ws ** 0.16;
	my $wc = 35.74 + (0.6215 * $temp) - (35.75 * $pow) + (0.4275 * $temp * $pow);
	return $wc;
}

sub weather_setup {
	use WWW::Wunderground::API;
	use Cache::FileCache;

	my $conf = $opt_c;
	if (!defined($conf)) {
		$conf = $ENV{'HOME'}."/.weather.conf";
	}

	my ($apikey, $location);
	my $allconf = $r->readconf($conf);
	if (defined($opt_a) && defined($allconf->{$opt_a})) {
		$location = $allconf->{$opt_a}->{location};
		$apikey = $allconf->{$opt_a}->{api_key};
	}
	if (!defined($apikey)) {
		$apikey = $allconf->{_}->{api_key};
	}
	if (!defined($location)) {
		$location = $allconf->{_}->{location};
	}
	if (!defined($apikey)) {
		print "api_key is not defined, bailing\n";
		return undef;
	}
	if (!defined($location)) {
		print "location is not defined, bailing\n";
		return undef;
	}
	my $wu = WWW::Wunderground::API->new(
		location => $location,
		api_key => $apikey,
		auto_api => 1,
		cache => Cache::FileCache->new({
			namespace => 'weathercache',
			default_expires_in => 2400,
		}),
	);

	return $wu;
}

sub voipms {
	if (!defined($mcli->{voipms})) {
		$mcli->{voipms} = voipms_setup();
	}
	my $voip = $mcli->{voipms};

	status("Voip.ms infoz");

	print "Balance: ";
	my $balinfo= $voip->getBalance();
	my $fmt = "%0.4f\n";
	printf $fmt, $balinfo;

	my $res = $voip->getCallAccounts;
	printf "%3s %12s %3s %s\n",
		"ID","Value","Reg","Host";
	my $count = 1;
	foreach my $acct (@{$res}) {
		if ($acct->{value} eq "all") {
			next;
		}
		printf "%2d. %-12s", $count++, $acct->{value};
		my $res2 = $voip->getRegistrationStatus(account => $acct->{value});
		my $regs = "";
		foreach my $r (@{$res2->{registrations}}) {
			$regs .= $r->{server_hostname}.",";
		}
		$regs =~ s/,$//;
		printf " %3s %s\n", $res2->{registered}, $regs;
	}
}

sub voipms_setup {
	use VOIP::MS;

	my $vconfig = $r->readconf($ENV{'HOME'}."/.voipms.conf")->{_};
	if (!defined($vconfig->{user}) || !defined($vconfig->{pass})) {
		print "User or Pass is Null and void, bailing for now\n";
		return undef;
	}
	my $voip = VOIP::MS->new(
		username => $vconfig->{user},
		password => $vconfig->{pass},
	);
	return $voip;
}


sub c1360 {
	if (!defined($mcli->{c1360})) {
		$mcli->{c1360} = c1360_setup();
	}
	my $ofx = $mcli->{c1360};
	my $fi = $mcli->{c1360_fi};
	my $url = $mcli->{c1360_url};
	my $fid = $mcli->{c1360_fid};

	status("CapitalOne360");

	my @accounts = $ofx->accounts;
	if (! @accounts) {
		printf "Something went wrong: %s\n", $ofx->response;
		return;
	}
	#print "Seems ok so far:\n";
	my $status = $ofx->response->signon_status_code( $fi );
	if (defined($status)) {
		if ($status != 0) {
			printf "Signon status code: %s\n", $status;
		}
	}

	# 1179955919 150002.02 140002.02 CHECKING ING Medical Fund
	print "    Account Available    Ledger\n";
	print "     Number   Balance   Balance     Type Name\n";
	my $afmt = "%11d %9.2f %9.2f %8s %s\n";

	my $totalbalance=0.0;
	foreach my $acct (@accounts) {
		if (!defined($acct)) {
			next;
		}
		if (ref($acct) eq "") {
			printf "Account is not a hash: %s\n", $acct;
			next;
		}
		my $id = $acct->{acctid};
		my $type = $acct->{accttype};
		my $desc = $acct->{desc};
		my $acct_obj = Finance::OFX::Account->new(
			URL => $url,
			Type => $type,
			ID => $id,
			FID => $fid
		);
		my $now = time();
		my $start = $now - 90*3600*24;
		my $txyn = 'Y';
		if ($opt_q == 1) {
			$txyn = 'N';
		}
		my $r = $ofx->{ua}->statement($acct_obj, start=> $start, end=> $now, transactions => 'Y');
		if (! $r->is_success) {
			print "Failure???\n";
		}
		if ($r->signon_status_code) {
			print "Status code ??\n";
		}
		my $trans = $r->ofx->{bankmsgsrsv1}{stmttrnrs};
		my $availbal = $trans->{stmtrs}->{availbal}->{balamt};
		my $ledgerbal = $trans->{stmtrs}->{ledgerbal}->{balamt};
		printf $afmt, $id, $availbal, $ledgerbal, $type, $desc;
		$totalbalance += $ledgerbal;

		# skip tx bits if quiet is asked for
		if ($opt_q == 1) {
			next;
		}
		my $ofxres = $r->ofx;
		if (! $ofxres->{bankmsgsrsv1}{stmttrnrs}{stmtrs}) {
			print "No transactions\n";
			next;
		}
		my $transaction = $ofxres->{bankmsgsrsv1}{stmttrnrs};
		if (Finance::OFX::transactionStatusCode($transaction)) {
			print "Statement request error: ".($transaction->{status}{message})."\n";
			next;
		}
		#print Dumper($transaction);
		my $txlist = $transaction->{stmtrs}{banktranlist};
		if (!defined($txlist)) {
			next;
		}
		#print Dumper($txlist);
		if (ref($txlist->{stmttrn}) eq "HASH") {
			c1360_fmt_tx($txlist->{stmttrn});
			next;
		}
		if (ref($txlist->{stmttrn}) ne "ARRAY") {
			printf "txlist->{stmttrn} is a %s\n", ref($txlist->{stmttrn});
			print Dumper($txlist->{stmttrn});
			next;
		}
		my @txs = @{$txlist->{stmttrn}};
		foreach my $tx (sort { $a->{dtposted} <=> $b->{dtposted} } @txs) {
			c1360_fmt_tx($tx);
		}
	}
	printf $afmt, 0, 0.0, $totalbalance, "", "Total";
}

sub c1360_fmt_tx {
	my ($tx) = @_;
	my $date = strftime("%Y%m%d %H:%M:%S",localtime($tx->{dtposted}));
	printf "      %4d %s %9.2f %s\n", $tx->{fitid}, $date, $tx->{trnamt}, $tx->{name};
}

sub c1360_setup {
	use Finance::OFX;
	use Finance::OFX::Institution;
	use Finance::OFX::Account;

	my ($org,$fid,$url,$user,$pass);
	my $config = $r->readconf( $ENV{'HOME'}."/.ofxcli.conf" )->{_};

	$org=$config->{org};
	$fid=$config->{fid};
	$url=$config->{url};
	$user=$config->{user};
	$pass=$config->{pass};

	my $fi = Finance::OFX::Institution->new(ORG=>$org, FID=>$fid, URL=>$url);
	my $ofx = Finance::OFX->new(
		userID=>$user,
		userPass=>$pass,
		Institution=>$fi,
		ssl_opts => {
			# XXX without this, we don't like the cert somehow!!!
			verify_hostname => 0,
		},
	);
	$mcli->{c1360_fi} = $fi;
	$mcli->{c1360_url} = $url;
	$mcli->{c1360_fid} = $fid;
	return $ofx;
}

sub parse_json {
	my ($str,$name) = @_;

	my $parsed;
	eval {
		$parsed = $mcli->{JSON}->decode( $str );
	};
	if ($@) {
		die("%s: json->decode('%s') Error %s\n", $name, $str, $@);
		return undef;
	}
	if ($opt_v > 0) {
		printf "Pretty %s: %s\n", $name, $mcli->{JSON}->pretty->encode( $parsed )."\n";;
	}
	return $parsed;
}

sub btcheckret {
	my ($call, $ret) = @_;
	if ($ret->{success} eq "true") {
		return $ret;
	}
	printf "bluetrade %s: %s\n", $call, $ret->{message};
	return undef;
}

sub bleutrade {
	if (!defined($mcli->{bleutrade})) {
		$mcli->{bleutrade} = bleutrade_setup();
	}
	my $bt = $mcli->{bleutrade};

	my $ret;
	foreach my $a (split(/,/,$opt_a)) {
	    if ($a =~ /depositaddr:([A-Z]+)/) {
		my $coin = $1;
		status("BlueTrade Deposit Addr for $coin");

		$ret = btcheckret('depositaddr',$bt->getdepositaddress($coin));
		if (!defined($ret)) {
			next;
		}

		my $addr = $ret->{result}->{Address};
		my $rcoin = $ret->{result}->{Currency};
		if (defined($addr)) {
			printf "%5s %s\n", $rcoin, $addr;
		}

		#print Dumper($bal);
		next;
	    } elsif ($a eq "ticker") {
		status("BleuTrade Ticker");
		while (1) {
		my $totalbalance=0.0;
		$ret = btcheckret('getbalances',$bt->getbalances);
		if (!defined($ret)) {
			next;
		}
		my $rmk = btcheckret('markets',$bt->getmarketsummaries);
		if (!defined($rmk)) {
			next;
		}

		my $str = "";
		foreach my $cur (@{$ret->{result}}) {
			my $addr = $cur->{CryptoAddress};
			if (!defined($addr)) {
				$addr = "<undef>";
			}
			my $currency = $cur->{Currency};
			my $btcrate = 0.0;
			if ($currency eq "BTC") {
				$btcrate = 1.0;
			} else {
			    foreach my $m (@{$rmk->{result}}) {
				if ($m->{MarketName} eq "${currency}_BTC") {
					$btcrate = $m->{Average};
					last;
				}
			    }
			}
			my $btcequiv = 0.0;
			if (defined($btcrate)) {
				$btcequiv = $cur->{Balance} * $btcrate;
			} else {
				$btcrate = 0.0;
			}
			if ($cur->{Balance} == 0.0) {
				next;
			}
			
			$str .= sprintf "%s=%.8f,%d/",
			    $cur->{Currency}, $cur->{Balance},
			    $btcrate * 100000000;
			$totalbalance += $btcequiv;
		}
		$str =~ s/\/$//;
		$str .= sprintf " %.8fBTC\n", $totalbalance;
		print $str;
		sleep(600);
		}
		next;
	    } elsif ($a eq "balances") {
		my $totalbalance=0.0;

		status("BlueTrade Balances");

		$ret = btcheckret('getbalances',$bt->getbalances);
		if (!defined($ret)) {
			next;
		}
		my $rmk = btcheckret('markets',$bt->getmarketsummaries);
		if (!defined($rmk)) {
			next;
		}

		printf "%5s %15s %15s %15s %15s %15s %s\n",
			"Curr.","Balance", "X/BTC", "BTC", "Available", "Pending",
			"Deposit Address";
		foreach my $cur (@{$ret->{result}}) {
			my $addr = $cur->{CryptoAddress};
			if (!defined($addr)) {
				$addr = "<undef>";
			}
			my $currency = $cur->{Currency};
			my $btcrate = 0.0;
			if ($currency eq "BTC") {
				$btcrate = 1.0;
			} else {
			    foreach my $m (@{$rmk->{result}}) {
				#print "comparing ${currency}_BTC to ".$m->{MarketName}."\n";
				if ($m->{MarketName} eq "${currency}_BTC") {
					$btcrate = $m->{Average};
					last;
				}
			    }
			}
			#print "btcrate = $btcrate\n";
			my $btcequiv = 0.0;
			if (defined($btcrate)) {
				$btcequiv = $cur->{Balance} * $btcrate;
			} else {
				$btcrate = 0.0;
			}
			
			printf "%5s %15.8f %15.8f %15.8f %15.8f %15.8f %s\n",
			    $cur->{Currency}, $cur->{Balance}, $btcrate, $btcequiv,
			    $cur->{Available}, $cur->{Pending}, $addr;
			$totalbalance += $btcequiv;
		}
		printf "%5s %15.8f %15.8f %15.8f\n", "Total", $totalbalance, $totalbalance, $totalbalance;

		#print Dumper($ret);
		next;
	    } elsif ($a eq "getorders") {
		$ret = btcheckret('getorders',$bt->getorders(undef,'OK'));
		if (!defined($ret)) {
			next;
		}
		printf "%8s %19s %6s %4s %9s %12s %12s %12s %12s\n",
			"Orderid", "Created", "Status", "Type", "Exchange", "Remains",
			"Price", "Quantity", "QBaseTrade";
		foreach my $o (@{$ret->{result}}) {
			printf "%8d %19s %6s %4s %9s %12.8f %12.8f %12.8f %12.8f\n",
				$o->{OrderId},
				$o->{Created},
				$o->{Status},
				$o->{Type},
				$o->{Exchange},
				$o->{QuantityRemaining},
				$o->{Price},
				$o->{Quantity},
				$o->{QuantityBaseTraded};
		}
		next;
	    } elsif ($a =~ /^getorderbook/) {
		my @markets = ("DCR_BTC");
		if ($a ne "getorderbook") {
			if ($a =~ /^getorderbook=(.*)$/) {
				@markets = split(/\//,$1);
			}
		}
		foreach my $m (@markets) {
			status("BleuTrade $m orderbook");
			$ret = btcheckret("orderbook x $m",$bt->getorderbook($m,"ALL",50));
			if (!defined($ret)) {
				next;
			}
			my @buys = @{$ret->{result}->{buy}};
			my @sells = @{$ret->{result}->{sell}};
			my $i=0;
			while (defined($buys[$i]) || defined($sells[$i])) {
				my $b = $buys[$i];
				my $s = $sells[$i];
				my ($bs, $ss) = ("","");
				if (defined($b)) {
					$bs = sprintf "%14.8f %10.8f", $b->{Quantity},
				    	$b->{Rate};
				}
				if (defined($s)) {
					$ss = sprintf "%14.8f %10.8f", $s->{Quantity},
				    	$s->{Rate};
				}
					
				$i++;
				printf "%02d. %25s       %25s\n", $i, $bs, $ss;
			}
			#print Dumper($ret);
			next;
		}
	    } elsif ($a =~ /^markethistory/) {
		my @markets = ("DCR_BTC");
		if ($a ne "getmarkethistory") {
			if ($a =~ /^getmarkethistory=(.*)$/) {
				@markets = split(/\//,$1);
			}
		}
		foreach my $m (@markets) {
			status("BleuTrade $m markethistory");
			$ret = btcheckret("markethistory", $bt->getmarkethistory);
			if (!defined($ret)) {
				next;
			}
			print Dumper($ret);
		}
	    } elsif ($a eq 'getorderhistory') {
		status("BleuTrade order history");
		$ret = $bt->getorderhistory;
		print Dumper($ret);
	    } elsif ($a eq "markets") {
		status("BlueTrade Markets");
		$ret = btcheckret('markets',$bt->getmarketsummaries);
		if (!defined($ret)) {
			next;
		}
		my $ml = { };
		foreach my $m (@{$ret->{result}}) {
			if ($m->{IsActive} ne "true") {
				next;
			}
			foreach my $v (keys %{$m}) {
				my $mylen = length($m->{$v});
				if (!defined($ml->{$v})) {
					$ml->{$v} = $mylen;
					next;
				}
				if ($mylen > $ml->{$v}) {
					$ml->{$v} = $mylen;
				}
			}
		}
		printf	"%".$ml->{TimeStamp}."s ".
			"%".$ml->{MarketName}."s ".
			"%".$ml->{Ask}."s ".
			"%".$ml->{High}."s ".
			"%".$ml->{Average}."s ".
			"%".$ml->{Low}."s ".
			"%".$ml->{Bid}."s ".
			"%".$ml->{BaseVolume}."s ".
			"\n",
			"TimeStamp",
			"Name", "Ask", "High", "Average", "Low", "Bid", "BaseVolume";
		foreach my $m (@{$ret->{result}}) {
			if ($m->{IsActive} ne "true") {
				next;
			}
			if (defined($a)) {
				if ($m->{MarketName} =~ /${a}/) {
					#
				} else {
					next;
				}
			}
			printf	"%".$ml->{TimeStamp}."s ".
				"%".$ml->{MarketName}."s ".
				"%".$ml->{Ask}.".8f ".
				"%".$ml->{High}.".8f ".
				"%".$ml->{Average}.".8f ".
				"%".$ml->{Low}.".8f ".
				"%".$ml->{Bid}.".8f ".
				"%".$ml->{BaseVolume}.".8f ".
				"\n",
				$m->{TimeStamp},
				$m->{MarketName}, $m->{Ask}, $m->{High},
				$m->{Average}, $m->{Low}, $m->{Bid},
				$m->{BaseVolume};
		}
	    } elsif (defined($a)) {
		printf "Unhandled a='%s'\n", $a;
		next;
	    }
	}
}
	

sub dcrbtc {
	if (!defined($mcli->{bleutrade})) {
		$mcli->{bleutrade} = bleutrade_setup();
	}

	status("1 DCR = ? BTC");
	my $dcrbtc = $mcli->{bleutrade}->dcrbtc;
	if ($dcrbtc->{success} eq "true") {
		foreach my $m (@{$dcrbtc->{result}}) {
			foreach my $v (sort keys %{$m}) {
				if ($opt_q > 0) {
					if ($v eq "Last") {
						print $m->{$v}."\n";
					}
					next;
				}
				print $v.": ".$m->{$v}."\n";
			}
		}
	}
	#print Dumper($dcrbtc);
}

# BlueTrade Exchange
sub btexch {
	if (!defined($opt_a)) {
		print "btexch: opt_a = <undef>\n";
		return;
	}

	if (!defined($mcli->{bleutrade})) {
		$mcli->{bleutrade} = bleutrade_setup();
	}

	my $bt = $mcli->{bleutrade};
	my $btexch = $bt->getmarketsummaries;

	foreach my $pair (split(/,/,$opt_a)) {
		my ($a,$b) = split(/:/,$pair);
		if ($btexch->{success} ne "true") {
			next;
		}
		foreach my $m (@{$btexch->{result}}) {
			if ($m->{MarketName} ne "${a}_${b}") {
				next;
			}

			status("1 ${a} = ? ${b}");
			print $m->{Average}."\n";
		}
	}

	#print Dumper($dcrbtc);
}

sub btcusd {
	if (!defined($mcli->{coinbase})) {
		$mcli->{coinbase} = coinbase_setup();
	}

	status("1 BTC = ? USD");
	my $coinbase = $mcli->{coinbase};
	my ($res) = $coinbase->get_spot_price("USD");
	my $cbavg = $res->{data}->{amount};

	if (!defined($mcli->{bitstamp})) {
		$mcli->{bitstamp} = bitstamp_setup();
	}
	my $bitstamp = $mcli->{bitstamp};
	$res = $bitstamp->ticker;
	my $bid = $res->{bid};
	my $ask = $res->{ask};
	my $bsavg = ($bid+$ask)/2;

	use Finance::Bank::Kraken;
	if (!defined($mcli->{kraken})) {
		$mcli->{kraken} = kraken_setup();
	}
	my $kraken = $mcli->{kraken};
	$res = $kraken->call(Public, 'Ticker', ['pair=XBTUSD']);
	my $parsed = parse_json( $res, 'kraken' );

	my $btc = $parsed->{result}->{XXBTZUSD};
	if (!defined($btc)) {
		print "Oops, btc not found\n";
		return;
	}
	$bid = $btc->{b}[0];
	$ask = $btc->{a}[0];
	my $kravg = ($bid+$ask)/2;

	my @vals;
	if (defined($kravg) && $kravg > 0.0) {
		if ($opt_q < 1) {
			printf "Kraken   %0.3f\n", $kravg;
		}
		push @vals, $kravg;
	}
	if (defined($bsavg) && $bsavg > 0.0) {
		if ($opt_q < 1) {
			printf "Bitstamp %0.3f\n", $bsavg;
		}
		push @vals, $bsavg;
	}
	if (defined($cbavg) && $cbavg > 0.0) {
		if ($opt_q < 1) {
			printf "Coinbase %0.3f\n", $cbavg;
		}
		push @vals, $cbavg;
	}
	my $avg = 0.0;
	my $act = 0;
	foreach my $a (@vals) {
		$avg += $a;
		$act ++;
	}
	$avg = $avg/$act;
	if ($opt_q < 1) {
		print "Average  ";
	}
	printf "%0.2f",$avg;
	if ($opt_q < 1) {
		print "\n";
	}
}

sub weather_init_lines {
	my $lines = { };
	$lines->{topline} = sprintf("%14s","Hour");
	$lines->{infline} = sprintf("%14s","Temp(F)");
	$lines->{spdline} = sprintf("%14s","WindSpeed");
	$lines->{feeline} = sprintf("%14s","WindChill");
	$lines->{humline} = sprintf("%14s","Humidity");
	$lines->{qpfline} = sprintf("%14s","Rainfall(in)");
	return $lines;
}

sub rank_length {
	my ($fname, $val) = @_;
	if (defined($stats->{lengths}->{$fname})) {
		if ($stats->{lengths}->{$fname} < length($val)) {
			$stats->{lengths}->{$fname} = length($val);
		}
	} else {
		$stats->{lengths}->{$fname} = length($val);
	}
}
sub get_length {
	my ($val) = @_;
	return $stats->{lengths}->{$val};
}
