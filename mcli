#!/usr/bin/perl

# Copyright (c) 2017 Todd T. Fries <todd@fries.net>
#
# Permission to use, copy, modify, and distribute this software for any
# purpose with or without fee is hereby granted, provided that the above
# copyright notice and this permission notice appear in all copies.
#
# THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
# WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
# MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
# ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
# WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
# ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
# OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.

use strict;
use warnings;

use Config::Tiny;
use Date::Manip;
use Getopt::Std;
use Data::Dumper;
use ReadConf;

STDERR->autoflush(1);
STDOUT->autoflush(1);

our $opt_p;
getopt('p:');

if (!defined($opt_p)) {
	$opt_p = "all";
}

our $mcli = { };

our $r = ReadConf->new();

if ($opt_p eq "all") {
	hetzner();
	namecheap();
	voipms();
	c1360();
}

if ($opt_p eq "hetzner") {
	hetzner();
}

if ($opt_p eq "namecheap") {
	namecheap();
}

if ($opt_p eq "voipms") {
	voipms();
}

if ($opt_p eq "c1360") {
	c1360();
}

if ($opt_p eq "coinbase") {
	coinbase();
}

if (0) {
use Finance::BlockIO;

my $ret = Finance::BlockIO->get_current_price;
print "BlockIO price ret: ",$ret,"\n";
}

1;

sub status {
	my ($str) = @_;

	print "\n==> $str status\n";
}

sub hetzner {

	if (!defined($mcli->{hetzner})) {
		$mcli->{hetzner} = hetzner_setup();
	}
	my $hetzner = $mcli->{hetzner};

	status("Hetzner server");

	my @hservers = $hetzner->servers;
	printf "%7s %12s %10s\n", "Number","Name","Cancel Date";
	foreach my $s (@hservers) {
		printf "%7d %12s %10s\n",
			$s->get('server_number'),
			$s->get('server_name'),
			$s->get('paid_until');
	}
}

sub hetzner_setup {
	use WWW::Hetzner;

	my $hconfig = $r->readconf($ENV{'HOME'}."/.hcli.conf")->{_};

	my $hetzner = WWW::Hetzner->new(
		huser => $hconfig->{huser},
		hpass => $hconfig->{hpass},
	);
	return $hetzner;
}

sub coinbase {
	if (!defined($mcli->{coinbase})) {
		$mcli->{coinbase} = coinbase_setup();
	}
	my $coinbase = $mcli->{coinbase};

	status("Coinbase spot price");

	my ($res) = $coinbase->get_spot_price("USD");
	my $price = $res->{data}->{amount};
	printf "Current bitcoin price in %s: %s\n", "USD", $price;

	my @resp = $coinbase->get_accounts();
	my @accts;
	foreach my $parsed (@resp) {
		if (defined($parsed->{data})) {
			foreach my $k ($parsed->{data}) {
				if (ref($k) eq "ARRAY") {
					foreach my $l (@{$k}) {
						push @accts,$l;
					}
				}
			}
		}
	}
	my $totalusd=0.0;
	foreach my $a (@accts) {
		$totalusd += $a->{native_balance}->{amount};
	}
	my $totalbtc=$totalusd/$price;
	printf "Total in coinbase wallets: %10.8f BTC (%8.3f USD)\n",
		$totalbtc, $totalusd;
}

sub coinbase_setup {
	use WebService::CoinBase::v2;

	my @scopes = (
        	"wallet:accounts:read",
        	"wallet:checkouts:read",
        	"wallet:checkouts:create",
        	#"wallet:orders:read",
        	#"wallet:orders:create",
        	"wallet:transactions:read",
        	"wallet:user:read",
	);

	my $scope = "";
	foreach my $s (@scopes) {
        	if (defined($scope)) {
                	$scope .= ",".$s;
        	} else {
                	$scope = $s;
        	}
	}
	my $coinbase = WebService::CoinBase::v2->new(
		scopes => $scope,
	);
	return $coinbase;
}

sub coinbase_order_accts {
	my $res;
	$res = $a->{type} cmp $b->{type};
	if ($res != 0) {
		return $res*-1;
	}
	$res = $a->{currency} cmp $b->{currency};
	if ($res != 0) {
		return $res;
	}
	return $a->{name} cmp $b->{name};
}


sub namecheap {
	if (!defined($mcli->{namecheap})) {
		$mcli->{namecheap} = namecheap_setup();
	}
	my $namecheap = $mcli->{namecheap};

	status("Namecheap domain");

	my $dns = $namecheap->dns();
	my $domlist = $dns->getdomains();

	foreach my $dd (@{$domlist->{Domain}}) {
		$dd->{ExpiresUD} = UnixDate(ParseDate($dd->{Expires}),"%s");
	}

	foreach my $dd (sort { $a->{ExpiresUD} <=> $b->{ExpiresUD} } @{$domlist->{Domain}}) {
		my %d = %{$dd};
		my $dom = $d{'Name'};
		printf STDERR "%9d %10s %s\n", $d{'ID'}, $d{'Expires'}, $d{'Name'};
	}
}

sub namecheap_setup {
	my $namecheap;

	use WWW::Namecheap::API;

	my $nconf = $ENV{'HOME'}."/.namecheap.conf";
	my $nconfig = $r->readconf($nconf)->{_};

	my $napiuser=$nconfig->{'apiuser'};
	my $napikey=$nconfig->{'apikey'};

	if (!defined($napiuser) || !defined($napikey)) {
		die "napiuser and napikey must be defined in the config file: $nconf";
	}

	$namecheap = WWW::Namecheap::API->new(
		#System => 'test',
		System => 'prod',
		ApiUser => $napiuser,
		ApiKey => $napikey,
		DefaultIp => $nconfig->{'defaultip'},
	);
	return $namecheap;
}

sub voipms {
	if (!defined($mcli->{voipms})) {
		$mcli->{voipms} = voipms_setup();
	}
	my $voip = $mcli->{voipms};

	status("Voip.ms infoz");

	print "Balance: ";
	my $balinfo= $voip->getBalance();
	my $fmt = "%0.4f\n";
	printf $fmt, $balinfo;

	my $res = $voip->getCallAccounts;
	printf "%3s %12s %3s %s\n",
		"ID","Value","Reg","Host";
	my $count = 1;
	foreach my $acct (@{$res}) {
		if ($acct->{value} eq "all") {
			next;
		}
		printf "%2d. %-12s", $count++, $acct->{value};
		my $res2 = $voip->getRegistrationStatus(account => $acct->{value});
		my $regs = "";
		foreach my $r (@{$res2->{registrations}}) {
			$regs .= $r->{server_hostname}.",";
		}
		$regs =~ s/,$//;
		printf " %3s %s\n", $res2->{registered}, $regs;
	}
}

sub voipms_setup {
	use VOIP::MS;

	my $vconfig = $r->readconf($ENV{'HOME'}."/.voipms.conf")->{_};
	if (!defined($vconfig->{user}) || !defined($vconfig->{pass})) {
		print "User or Pass is Null and void, bailing for now\n";
		exit(1);
	}
	my $voip = VOIP::MS->new(
		username => $vconfig->{user},
		password => $vconfig->{pass},
	);
	return $voip;
}


sub c1360 {
	if (!defined($mcli->{c1360})) {
		$mcli->{c1360} = c1360_setup();
	}
	my $ofx = $mcli->{c1360};
	my $fi = $mcli->{c1360_fi};
	my $url = $mcli->{c1360_url};
	my $fid = $mcli->{c1360_fid};

	status("CapitalOne360");

	my @accounts = $ofx->accounts;
	if (! @accounts) {
		printf "Something went wrong: %s\n", $ofx->response;
		exit(1);
	}
	print "Seems ok so far:\n";
	#print recurse_dump($ofx->response->ofx_header());
	#print "Response:\n";
	#print recurse_dump($ofx->response);
	my $status = $ofx->response->signon_status_code( $fi );
	printf "Signon status code: %s\n", defined($status) ? $status : "<undef>";

	# 1179955919 150002.02 140002.02 CHECKING ING Medical Fund
	print "    Account Available    Ledger\n";
	print "     Number   Balance   Balance     Type Name\n";
	my $afmt = "%11d %9.2f %9.2f %8s %s\n";

	my $totalbalance=0.0;
	foreach my $acct (@accounts) {
		if (!defined($acct)) {
			next;
		}
		if (ref($acct) eq "") {
			printf "Account is not a hash: %s\n", $acct;
			next;
		}
		my $id = $acct->{acctid};
		my $type = $acct->{accttype};
		my $desc = $acct->{desc};
		my $acct_obj = Finance::OFX::Account->new(
			URL => $url,
			Type => $type,
			ID => $id,
			FID => $fid
		);
		my $now = time();
		my $r = $ofx->{ua}->statement($acct_obj, start=> $now, end=> $now);
		my $trans = $r->ofx->{bankmsgsrsv1}{stmttrnrs};
		my $availbal = $trans->{stmtrs}->{availbal}->{balamt};
		my $ledgerbal = $trans->{stmtrs}->{ledgerbal}->{balamt};
		printf $afmt, $id, $availbal, $ledgerbal, $type, $desc;
		$totalbalance += $ledgerbal;
	}
	printf $afmt, 0, 0.0, $totalbalance, "", "Total";
}

sub c1360_setup {
	use Finance::OFX;
	use Finance::OFX::Institution;
	use Finance::OFX::Account;

	my ($org,$fid,$url,$user,$pass);
	my $config = $r->readconf( $ENV{'HOME'}."/.ofxcli.conf" )->{_};

	$org=$config->{org};
	$fid=$config->{fid};
	$url=$config->{url};
	$user=$config->{user};
	$pass=$config->{pass};

	my $fi = Finance::OFX::Institution->new(ORG=>$org, FID=>$fid, URL=>$url);
	my $ofx = Finance::OFX->new(
		userID=>$user,
		userPass=>$pass,
		Institution=>$fi,
		ssl_opts => {
			# XXX without this, we don't like the cert somehow!!!
			verify_hostname => 0,
		},
	);
	$mcli->{c1360_fi} = $fi;
	$mcli->{c1360_url} = $url;
	$mcli->{c1360_fid} = $fid;
	return $ofx;
}
