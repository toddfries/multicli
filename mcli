#!/usr/bin/perl

# Copyright (c) 2017 Todd T. Fries <todd@fries.net>
#
# Permission to use, copy, modify, and distribute this software for any
# purpose with or without fee is hereby granted, provided that the above
# copyright notice and this permission notice appear in all copies.
#
# THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
# WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
# MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
# ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
# WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
# ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
# OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.

use strict;
use warnings;

use Config::Tiny;
my $config;

STDERR->autoflush(1);
STDOUT->autoflush(1);

#
# BEGIN Hetzner
#
use WWW::Hetzner;

my $hconf = $ENV{'HOME'}."/.hcli.conf";
if (! -f $hconf) {
        die("config file '$hconf' does not exist");
}
$config = Config::Tiny->read( $hconf );
my $hconfig = $config->{_};

my $hetzner = WWW::Hetzner->new(
        huser => $hconfig->{huser},
        hpass => $hconfig->{hpass},
);

#
# END Hetzner
#

#
# BEGIN Namecheap
#

use WWW::Namecheap::API;

my $nconf=$ENV{'HOME'}."/.namecheap.conf";
if (! -f $nconf) {
        die "need a conf file, $nconf not found";
}
$config = Config::Tiny->read( $nconf );
my $nconfig = $config->{_};

my $napiuser=$nconfig->{'apiuser'};
my $napikey=$nconfig->{'apikey'};

if (!defined($napiuser) || !defined($napikey)) {
        die "napiuser and napikey must be defined in the config file: $nconf";
}
my $namecheap = WWW::Namecheap::API->new(
        #System => 'test',
        System => 'prod',
        ApiUser => $napiuser,
        ApiKey => $napikey,
        DefaultIp => $nconfig->{'defaultip'},
        #DefaultUser
        #ApiUrl
        #Agent
);

#
# END Namecheap
#

#
# BEGIN Voip.ms
#
use VOIP::MS;

my $vconf = $ENV{'HOME'}."/.voipms.conf";
if (! -f $vconf) {
        die("vconfig file $vconf does not exist, need user and pass from it, bailing");
}
$config = Config::Tiny->read($vconf);
my $vconfig = $config->{_};
if (!defined($vconfig->{user}) || !defined($vconfig->{pass})) {
        print "User or Pass is Null and void, bailing for now\n";
        exit(1);
}
my $voip = VOIP::MS->new(username => $vconfig->{user},
        password => $vconfig->{pass});

#
# END Voip.ms
#

#
# BEGIN CapitalOne360
#
use Finance::OFX;
use Finance::OFX::Institution;
use Finance::OFX::Account;

my ($org,$fid,$url,$user,$pass);
my $oconf = $ENV{'HOME'}."/.ofxcli.conf";

if (! -f $oconf) {
	die("$oconf not found, bailing");
}
$config = Config::Tiny->read($oconf);
my $oconfig = $config->{_};

$org=$oconfig->{org};
$fid=$oconfig->{fid};
$url=$oconfig->{url};
$user=$oconfig->{user};
$pass=$oconfig->{pass};

my $fi = Finance::OFX::Institution->new(ORG=>$org, FID=>$fid, URL=>$url);
my $ofx = Finance::OFX->new(
        userID=>$user,
        userPass=>$pass,
        Institution=>$fi,
        ssl_opts => {
                # XXX without this, we don't like the cert somehow, fixme!!!
                verify_hostname => 0,
        },
);

#
# END CaptalOne360
#
if (1) {
status("Hetzner server");

my @hservers = $hetzner->servers;
printf "%7s %12s %10s\n", "Number","Name","Cancel Date";
foreach my $s (@hservers) {
	printf "%7d %12s %10s\n",
		$s->get('server_number'),
		$s->get('server_name'),
		$s->get('paid_until');
}

status("Namecheap domain");

my $dns = $namecheap->dns();
my $domlist = $dns->getdomains();

foreach my $dd (@{$domlist->{Domain}}) {
	my %d = %{$dd};
	my $dom = $d{'Name'};
	printf STDERR "%9d %10s %s\n", $d{'ID'}, $d{'Expires'}, $d{'Name'};
}
}
status("Voip.ms infoz");

print "Balance\n",
my $balinfo= $voip->getBalance();
my $fmt = "%0.8f\n";
printf $fmt, $balinfo;

my $res = $voip->getCallAccounts;
printf "%3s %12s %3s %s\n",
	"ID","Value","Reg","Host";
my $count = 1;
foreach my $acct (@{$res}) {
	if ($acct->{value} eq "all") {
		next;
	}
	printf "%2d. %-12s", $count++, $acct->{value};
	my $res2 = $voip->getRegistrationStatus(account => $acct->{value});
	my $regs = "";
	foreach my $r (@{$res2->{registrations}}) {
		$regs .= $r->{server_hostname}.",";
	}
	$regs =~ s/,$//;
	printf " %3s %s\n", $res2->{registered}, $regs;
}

status("CapitalOne360");

my @accounts = $ofx->accounts;
if (! @accounts) {
        printf "Something went wrong: %s\n", $ofx->response;
        exit(1);
}
print "Seems ok so far:\n";
#print recurse_dump($ofx->response->ofx_header());
#print "Response:\n";
#print recurse_dump($ofx->response);
my $status = $ofx->response->signon_status_code( $fi );
printf "Signon status code: %s\n", defined($status) ? $status : "<undef>";

      # 1179955919 150002.02 140002.02 CHECKING ING Medical Fund
print "    Account Available    Ledger\n";
print "     Number   Balance   Balance     Type Name\n";
my $afmt = "%11d %9.2f %9.2f %8s %s\n";

my $totalbalance=0.0;
foreach my $acct (@accounts) {
        if (!defined($acct)) {
                next;
        }
        if (ref($acct) eq "") {
                printf "Account is not a hash: %s\n", $acct;
                next;
        }
        my $id = $acct->{acctid};
        my $type = $acct->{accttype};
        my $desc = $acct->{desc};
        my $acct_obj = Finance::OFX::Account->new(
                URL => $url,
                Type => $type,
                ID => $id,
                FID => $fid
        );
        my $now = time();
        my $r = $ofx->{ua}->statement($acct_obj, start=> $now, end=> $now);
        my $trans = $r->ofx->{bankmsgsrsv1}{stmttrnrs};
        my $availbal = $trans->{stmtrs}->{availbal}->{balamt};
        my $ledgerbal = $trans->{stmtrs}->{ledgerbal}->{balamt};
        printf $afmt, $id, $availbal, $ledgerbal, $type, $desc;
	$totalbalance += $ledgerbal;
}
printf $afmt, 0, 0.0, $totalbalance, "", "Total";

1;

sub status {
	my ($str) = @_;

	print "\n==> $str status\n";
}
