#!/usr/bin/perl

# Copyright (c) 2017 Todd T. Fries <todd@fries.net>
#
# Permission to use, copy, modify, and distribute this software for any
# purpose with or without fee is hereby granted, provided that the above
# copyright notice and this permission notice appear in all copies.
#
# THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
# WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
# MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
# ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
# WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
# ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
# OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.

use strict;
use warnings;

use Config::Tiny;
use Date::Manip;
use Getopt::Std;
use Data::Dumper;
use POSIX qw(strftime);
use ReadConf;

STDERR->autoflush(1);
STDOUT->autoflush(1);

our $opt_a;
our $opt_p;
our $opt_q = 0;
our $opt_v = 0;

getopt('a:p:q:v');

if (!defined($opt_p)) {
	$opt_p = "all";
}

our $mcli = { };

our $r = ReadConf->new();

if ($opt_p eq "all") {
	hetzner();
	namecheap();
	voipms();
	c1360();
}

if ($opt_p eq "hetzner") {
	hetzner();
}

if ($opt_p eq "namecheap") {
	namecheap();
}

if ($opt_p eq "voipms") {
	voipms();
}

if ($opt_p eq "c1360") {
	c1360();
}

if ($opt_p eq "coinbase") {
	coinbase();
}

if ($opt_p eq "kraken") {
	kraken();
}
if ($opt_p eq "bitstamp") {
	bitstamp();
}
if ($opt_p eq "bci") {
	bci();
}
if ($opt_p eq "bw") {
	bw();
}
if ($opt_p eq "btcusd") {
	btcusd();
}

if (0) {
use Finance::BlockIO;

my $ret = Finance::BlockIO->get_current_price;
print "BlockIO price ret: ",$ret,"\n";
}

1;

sub status {
	my ($str) = @_;
	if ($opt_q > 0) {
		return;
	}

	print "\n==> $str status\n";
}

sub hetzner {

	if (!defined($mcli->{hetzner})) {
		$mcli->{hetzner} = hetzner_setup();
	}
	my $hetzner = $mcli->{hetzner};

	status("Hetzner server");

	my @hservers = $hetzner->servers;
	printf "%7s %12s %10s\n", "Number","Name","Cancel Date";
	foreach my $s (@hservers) {
		printf "%7d %12s %10s\n",
			$s->get('server_number'),
			$s->get('server_name'),
			$s->get('paid_until');
	}
}

sub hetzner_setup {
	use WWW::Hetzner;

	my $hconfig = $r->readconf($ENV{'HOME'}."/.hcli.conf")->{_};

	my $hetzner = WWW::Hetzner->new(
		huser => $hconfig->{huser},
		hpass => $hconfig->{hpass},
	);
	return $hetzner;
}

sub coinbase {
	if (!defined($mcli->{coinbase})) {
		$mcli->{coinbase} = coinbase_setup();
	}
	my $coinbase = $mcli->{coinbase};

	status("Coinbase spot price");

	my ($res) = $coinbase->get_spot_price("USD");
	my $price = $res->{data}->{amount};
	if ($opt_q > 0) {
		print $price;
		return;
	}
	printf "Current bitcoin price in %s: %s\n", "USD", $price;

	my @resp = $coinbase->get_accounts();
	my @accts;
	foreach my $parsed (@resp) {
		if (defined($parsed->{data})) {
			foreach my $k ($parsed->{data}) {
				if (ref($k) eq "ARRAY") {
					foreach my $l (@{$k}) {
						push @accts,$l;
					}
				}
			}
		}
	}
	my $totalusd=0.0;
	foreach my $a (@accts) {
		$totalusd += $a->{native_balance}->{amount};
	}
	my $totalbtc=$totalusd/$price;
	printf "Total in coinbase wallets: %10.8f BTC (%8.3f USD)\n",
		$totalbtc, $totalusd;
}

sub coinbase_setup {
	use WebService::CoinBase::v2;

	my @scopes = (
        	"wallet:accounts:read",
        	"wallet:checkouts:read",
        	"wallet:checkouts:create",
        	#"wallet:orders:read",
        	#"wallet:orders:create",
        	"wallet:transactions:read",
        	"wallet:user:read",
	);

	my $scope = "";
	foreach my $s (@scopes) {
        	if (defined($scope)) {
                	$scope .= ",".$s;
        	} else {
                	$scope = $s;
        	}
	}
	my $coinbase = WebService::CoinBase::v2->new(
		scopes => $scope,
	);
	return $coinbase;
}

sub coinbase_order_accts {
	my $res;
	$res = $a->{type} cmp $b->{type};
	if ($res != 0) {
		return $res*-1;
	}
	$res = $a->{currency} cmp $b->{currency};
	if ($res != 0) {
		return $res;
	}
	return $a->{name} cmp $b->{name};
}

sub kraken {
	use Finance::Bank::Kraken;
	if (!defined($mcli->{kraken})) {
		$mcli->{kraken} = kraken_setup();
	}
	my $kraken = $mcli->{kraken};

	if (!defined($opt_a)) {
		$opt_a = "ticker";
	}

	if ($opt_a eq "ticker") {

		status("Kraken spot price");

		my $res = $kraken->call(Public, 'Ticker', ['pair=XBTUSD']);
		my $parsed = parse_json( $res, 'kraken' );

		#print Dumper($parsed);
		my $btc = $parsed->{result}->{XXBTZUSD};
		if (!defined($btc)) {
			print "Oops, btc not found\n";
			return;
		}
		my $bid = $btc->{b}[0];
		my $ask = $btc->{a}[0];
		my $avg = ($bid+$ask)/2;
		if ($opt_q > 0) {
			print $avg;
			return;
		}
		printf "Bid %s\nAsk %s\n", $bid, $ask;
		printf "Avg %s\n", $avg;
		printf "Low %s %s (today 24hrs)\n", $btc->{l}[0], $btc->{l}[1];
		printf "Hi  %s %s (today 24hrs)\n", $btc->{h}[0], $btc->{h}[1];
		printf "Vol %s %s (today 24hrs)\n", $btc->{v}[0], $btc->{v}[1];
		printf "Wav %s %s (today 24hrs)\n", $btc->{p}[0], $btc->{p}[1];
		printf "Lst %s %s (price volume)\n", $btc->{c}[0], $btc->{c}[1];
	}
	if ($opt_a eq "assets") {
		my $res = $kraken->call(Public, 'Assets');
		my $parsed = parse_json( $res, 'kraken' );
		foreach my $asset (sort keys %{$parsed->{result}}) {
			my $r = $parsed->{result}->{$asset};
			printf "%4s %4s %8s %2d %2d\n", $asset, $r->{altname},
			    $r->{aclass}, $r->{decimals},
			    $r->{display_decimals};
		}
		#print Dumper($parsed);
	}
	if ($opt_a eq "assetpairs") {
		my $res = $kraken->call(Public, 'AssetPairs');
		my $parsed = parse_json( $res, 'kraken' );
		foreach my $pair (sort keys %{$parsed->{result}}) {
			my $r = $parsed->{result}->{$pair};
			printf "%11s %11s %8s %4s %4s\n", $pair, $r->{altname},
			    $r->{aclass_base}, $r->{base}, $r->{quote};
		}
		#print Dumper($parsed);
	}
		
}

sub kraken_setup {
	use Finance::Bank::Kraken;
	use JSON;
	if (!defined($mcli->{JSON})) {
		$mcli->{JSON} = JSON->new->allow_nonref;
	}

	my $kraken = Finance::Bank::Kraken->new;
	return $kraken;
}

sub bitstamp {
	#use Finance::BitStamp::API;
	if (!defined($mcli->{bitstamp})) {
		$mcli->{bitstamp} = bitstamp_setup();
	}
	my $bitstamp = $mcli->{bitstamp};

	status("BitStamp spot price");

	my $res = $bitstamp->ticker;
	#print Dumper($res);
	#my $parsed = parse_json( $res, 'kraken' );

	#print Dumper($parsed);
	my $bid = $res->{bid};
	my $ask = $res->{ask};
	my $avg = ($bid+$ask)/2;
	if ($opt_q > 0) {
		print $avg;
		return;
	}
	printf "Bid %s\nAsk %s\n", $bid, $ask;
	printf "Avg %s\n", $avg;
	printf "Low %s\n", $res->{low};
	printf "Hi  %s\n", $res->{high};
	printf "Vol %s\n", $res->{volume};
}

sub bitstamp_setup {
	use Finance::BitStamp::API;
	use JSON;
	if (!defined($mcli->{JSON})) {
		$mcli->{JSON} = JSON->new->allow_nonref;
	}

	my $bitstamp = Finance::BitStamp::API->new;
	return $bitstamp;
}

sub bci {
	if (!defined($mcli->{bci})) {
		$mcli->{bci} = bci_setup();
	}
	my $bci = $mcli->{bci};
	$bci->ua->agent("OpenBSD ftp");

	status("BlockChain.info lastblock");

	my $res = $bci->latestblock;

	my $hash = $res->{hash};
	my @txi = @{$res->{txIndexes}};
	my $block_index = $res->{block_index};
	my $time = $res->{time};
	my $height = $res->{height};
	if ($opt_q > 0) {
		print $height;
		return;
	}
	printf "%s %d %s\n", strftime("%Y%m%d %H:%M:%S",localtime($time)),
	    $height, $hash;
}

sub bci_setup {
	use WebService::BlockChain::Info;
	use JSON;
	if (!defined($mcli->{JSON})) {
		$mcli->{JSON} = JSON->new->allow_nonref;
	}

	my $bci = WebService::BlockChain::Info->new;
	return $bci;
}
sub bw {
	if (!defined($mcli->{bw})) {
		$mcli->{bw} = bw_setup();
	}
	my $bw = $mcli->{bw};
	$bw->ua->agent("OpenBSD ftp");

	status("bw.com account info");

	my $res = $bw->account;
	print Dumper($res);
}

sub bw_setup {
	use WebService::BW;
	use JSON;
	if (!defined($mcli->{JSON})) {
		$mcli->{JSON} = JSON->new->allow_nonref;
	}

	my $conf = $ENV{'HOME'}."/.bw.conf";
	my $config = $r->readconf($conf)->{_};
	my $key = $config->{key};
	my $sec = $config->{sec};
	my $user = $config->{user};

	my $bw = WebService::BW->new( api_key => $key, api_secret => $sec,
		userName => $user );

	return $bw;
}

sub namecheap {
	if (!defined($mcli->{namecheap})) {
		$mcli->{namecheap} = namecheap_setup();
	}
	my $namecheap = $mcli->{namecheap};

	status("Namecheap domain");

	my $dns = $namecheap->dns();
	my $domlist = $dns->getdomains();

	foreach my $dd (@{$domlist->{Domain}}) {
		$dd->{ExpiresUD} = UnixDate(ParseDate($dd->{Expires}),"%s");
	}

	foreach my $dd (sort { $a->{ExpiresUD} <=> $b->{ExpiresUD} } @{$domlist->{Domain}}) {
		my %d = %{$dd};
		my $dom = $d{'Name'};
		printf STDERR "%9d %10s %s\n", $d{'ID'}, $d{'Expires'}, $d{'Name'};
	}
}

sub namecheap_setup {
	my $namecheap;

	use WWW::Namecheap::API;

	my $nconf = $ENV{'HOME'}."/.namecheap.conf";
	my $nconfig = $r->readconf($nconf)->{_};

	my $napiuser=$nconfig->{'apiuser'};
	my $napikey=$nconfig->{'apikey'};

	if (!defined($napiuser) || !defined($napikey)) {
		die "napiuser and napikey must be defined in the config file: $nconf";
	}

	$namecheap = WWW::Namecheap::API->new(
		#System => 'test',
		System => 'prod',
		ApiUser => $napiuser,
		ApiKey => $napikey,
		DefaultIp => $nconfig->{'defaultip'},
	);
	return $namecheap;
}

sub voipms {
	if (!defined($mcli->{voipms})) {
		$mcli->{voipms} = voipms_setup();
	}
	my $voip = $mcli->{voipms};

	status("Voip.ms infoz");

	print "Balance: ";
	my $balinfo= $voip->getBalance();
	my $fmt = "%0.4f\n";
	printf $fmt, $balinfo;

	my $res = $voip->getCallAccounts;
	printf "%3s %12s %3s %s\n",
		"ID","Value","Reg","Host";
	my $count = 1;
	foreach my $acct (@{$res}) {
		if ($acct->{value} eq "all") {
			next;
		}
		printf "%2d. %-12s", $count++, $acct->{value};
		my $res2 = $voip->getRegistrationStatus(account => $acct->{value});
		my $regs = "";
		foreach my $r (@{$res2->{registrations}}) {
			$regs .= $r->{server_hostname}.",";
		}
		$regs =~ s/,$//;
		printf " %3s %s\n", $res2->{registered}, $regs;
	}
}

sub voipms_setup {
	use VOIP::MS;

	my $vconfig = $r->readconf($ENV{'HOME'}."/.voipms.conf")->{_};
	if (!defined($vconfig->{user}) || !defined($vconfig->{pass})) {
		print "User or Pass is Null and void, bailing for now\n";
		exit(1);
	}
	my $voip = VOIP::MS->new(
		username => $vconfig->{user},
		password => $vconfig->{pass},
	);
	return $voip;
}


sub c1360 {
	if (!defined($mcli->{c1360})) {
		$mcli->{c1360} = c1360_setup();
	}
	my $ofx = $mcli->{c1360};
	my $fi = $mcli->{c1360_fi};
	my $url = $mcli->{c1360_url};
	my $fid = $mcli->{c1360_fid};

	status("CapitalOne360");

	my @accounts = $ofx->accounts;
	if (! @accounts) {
		printf "Something went wrong: %s\n", $ofx->response;
		exit(1);
	}
	print "Seems ok so far:\n";
	my $status = $ofx->response->signon_status_code( $fi );
	printf "Signon status code: %s\n", defined($status) ? $status : "<undef>";

	# 1179955919 150002.02 140002.02 CHECKING ING Medical Fund
	print "    Account Available    Ledger\n";
	print "     Number   Balance   Balance     Type Name\n";
	my $afmt = "%11d %9.2f %9.2f %8s %s\n";

	my $totalbalance=0.0;
	foreach my $acct (@accounts) {
		if (!defined($acct)) {
			next;
		}
		if (ref($acct) eq "") {
			printf "Account is not a hash: %s\n", $acct;
			next;
		}
		my $id = $acct->{acctid};
		my $type = $acct->{accttype};
		my $desc = $acct->{desc};
		my $acct_obj = Finance::OFX::Account->new(
			URL => $url,
			Type => $type,
			ID => $id,
			FID => $fid
		);
		my $now = time();
		my $start = $now - 90*3600*24;
		my $r = $ofx->{ua}->statement($acct_obj, start=> $start, end=> $now, transactions => 'Y');
		if (! $r->is_success) {
			print "Failure???\n";
		}
		if ($r->signon_status_code) {
			print "Status code ??\n";
		}
		my $trans = $r->ofx->{bankmsgsrsv1}{stmttrnrs};
		my $availbal = $trans->{stmtrs}->{availbal}->{balamt};
		my $ledgerbal = $trans->{stmtrs}->{ledgerbal}->{balamt};
		printf $afmt, $id, $availbal, $ledgerbal, $type, $desc;
		$totalbalance += $ledgerbal;
		my $ofxres = $r->ofx;
		if (! $ofxres->{bankmsgsrsv1}{stmttrnrs}{stmtrs}) {
			print "No transactions\n";
			next;
		}
		my $transaction = $ofxres->{bankmsgsrsv1}{stmttrnrs};
		if (Finance::OFX::transactionStatusCode($transaction)) {
			print "Statement request error: ".($transaction->{status}{message})."\n";
			next;
		}
		#print Dumper($transaction);
		my $txlist = $transaction->{stmtrs}{banktranlist};
		if (!defined($txlist)) {
			next;
		}
		#print Dumper($txlist);
		my @txs = @{$txlist->{stmttrn}};
		foreach my $tx (sort { $a->{dtposted} <=> $b->{dtposted} } @txs) {
			#printf "      tx is a %s\n", ref($tx);
			#next;
			my $date = strftime("%Y%m%d %H:%M:%S",localtime($tx->{dtposted}));
			printf "      %4d %s %9.2f %s\n", $tx->{fitid}, $date, $tx->{trnamt}, $tx->{name};
		}
	}
	printf $afmt, 0, 0.0, $totalbalance, "", "Total";
}

sub c1360_setup {
	use Finance::OFX;
	use Finance::OFX::Institution;
	use Finance::OFX::Account;

	my ($org,$fid,$url,$user,$pass);
	my $config = $r->readconf( $ENV{'HOME'}."/.ofxcli.conf" )->{_};

	$org=$config->{org};
	$fid=$config->{fid};
	$url=$config->{url};
	$user=$config->{user};
	$pass=$config->{pass};

	my $fi = Finance::OFX::Institution->new(ORG=>$org, FID=>$fid, URL=>$url);
	my $ofx = Finance::OFX->new(
		userID=>$user,
		userPass=>$pass,
		Institution=>$fi,
		ssl_opts => {
			# XXX without this, we don't like the cert somehow!!!
			verify_hostname => 0,
		},
	);
	$mcli->{c1360_fi} = $fi;
	$mcli->{c1360_url} = $url;
	$mcli->{c1360_fid} = $fid;
	return $ofx;
}

sub parse_json {
	my ($str,$name) = @_;

	my $parsed;
	eval {
		$parsed = $mcli->{JSON}->decode( $str );
	};
	if ($@) {
		die("%s: json->decode('%s') Error %s\n", $name, $str, $@);
		return undef;
	}
	if ($opt_v > 0) {
		printf "Pretty %s: %s\n", $name, $mcli->{JSON}->pretty->encode( $parsed )."\n";;
	}
	return $parsed;
}

sub btcusd {
	if (!defined($mcli->{coinbase})) {
		$mcli->{coinbase} = coinbase_setup();
	}
	my $coinbase = $mcli->{coinbase};
	my ($res) = $coinbase->get_spot_price("USD");
	my $cbavg = $res->{data}->{amount};

	if (!defined($mcli->{bitstamp})) {
		$mcli->{bitstamp} = bitstamp_setup();
	}
	my $bitstamp = $mcli->{bitstamp};
	$res = $bitstamp->ticker;
	my $bid = $res->{bid};
	my $ask = $res->{ask};
	my $bsavg = ($bid+$ask)/2;

	use Finance::Bank::Kraken;
	if (!defined($mcli->{kraken})) {
		$mcli->{kraken} = kraken_setup();
	}
	my $kraken = $mcli->{kraken};
	$res = $kraken->call(Public, 'Ticker', ['pair=XBTUSD']);
	my $parsed = parse_json( $res, 'kraken' );

	my $btc = $parsed->{result}->{XXBTZUSD};
	if (!defined($btc)) {
		print "Oops, btc not found\n";
		return;
	}
	$bid = $btc->{b}[0];
	$ask = $btc->{a}[0];
	my $kravg = ($bid+$ask)/2;

	my $avg = ($kravg+$bsavg+$cbavg)/3;
	printf "%0.2f",$avg;
}
