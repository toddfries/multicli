#!/usr/bin/perl

# Copyright (c) 2017,2018 Todd T. Fries <todd@fries.net>
#
# Permission to use, copy, modify, and distribute this software for any
# purpose with or without fee is hereby granted, provided that the above
# copyright notice and this permission notice appear in all copies.
#
# THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
# WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
# MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
# ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
# WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
# ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
# OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.

use strict;
use warnings;

use Config::Tiny;
use Date::Manip;
use Date::Manip::Date;
use Getopt::Std;
use Data::Dumper;
use POSIX qw(strftime);
use ReadConf;

STDERR->autoflush(1);
STDOUT->autoflush(1);

our $opt_a; # 'additional args used per personality'
our $opt_p; # 'personality'
our $opt_q = 0;
our $opt_t;    # bci/rawtx txid
our $opt_v = 0;
our $opt_c; # config file, if desired to over-ride
our $opt_H; # weather historic date
our $opt_o; # var1=val;var2=val1,val2,val3

our $opt_C; # hetzner min cpu
our $opt_D; # hetzner min disk
our $opt_M; # hetzner min mem

getopts('a:c:o:p:q:t:vC:D:H:M:');

if (!defined($opt_p)) {
	$opt_p = "all";
}

our $opt = { };
if (defined($opt_o)) {
	foreach my $o (split(/;/,$opt_o)) {
		if ($o =~ /^(\s{0,}#|\s{0,}$)/) {
			next;
		}
		if ($o =~ /^(.*)\s{0,}=\s{0,}(.*)$/) {
			$opt->{$1} = $2;
		}
	}
}

our $mcli = { };
our $stats = { };

our $r = ReadConf->new();

our ($snolen, $dclen, $prodlen, $namlen, $ip6len, $ip4len, $netlen, $gwlen);
our $dnow = Date::Manip::Date->new('now');

foreach my $p (split(/,/,$opt_p)) {
if ($p eq "all") {
	hetzner();
	namecheap();
	voipms();
	c1360();
}

if ($p eq "hetzner") {
	hetzner();
}

if ($p eq "namecheap") {
	namecheap();
}

if ($p eq "voipms") {
	voipms();
}

if ($p eq "c1360") {
	c1360();
}

if ($p eq "coinbase") {
	coinbase();
}

if ($p eq "kraken") {
	kraken();
}
if ($p eq "bitstamp") {
	bitstamp();
}
if ($p eq "bci") {
	bci();
}
if ($p eq "bw") {
	bw();
}
if ($p eq "bleutrade") {
	bleutrade();
}
if ($p eq "btexch") {
	btexch();
}
if ($p eq "btcusd") {
	btcusd();
}
if ($p eq "dcrbtc") {
	dcrbtc();
}

if ($p eq "weather") {
	weather();
}
}

#if (0) {
#use Finance::BlockIO;
#
#my $ret = Finance::BlockIO->get_current_price;
#print "BlockIO price ret: ",$ret,"\n";
#}

1;

sub status {
	my ($str) = @_;
	if ($opt_q > 0) {
		return;
	}

	print "\n==> $str status\n";
}

sub hetzner {

	if (!defined($mcli->{hetzner})) {
		$mcli->{hetzner} = hetzner_setup();
	}
	my $hetzner = $mcli->{hetzner};

	if (defined($opt->{update})) {
		hetzner_update($hetzner);
	}
	if (defined($opt->{query})) {
		hetzner_query($hetzner);
	}

	my $res;
	my $stash = { };
	my $treq=$dnow->printf("traffic?type=month&from=%Y-%m-01&to=%Y-%m-31");

	status("Hetzner server");

	my @hservers = $hetzner->servers;
	if (! @hservers ) {
		die "No servers retrieved";
	}
	# a word about "reset" api. no arg = v4 only hosts, no v6 only
	my @resets;
	#print Dumper(@hservers);
	# see json/hetzner.hservers
	foreach my $s (@hservers) {
		my $sno = $s->vget('server_number');
		rank_length('srv_no',   $sno);
		rank_length('srv_dc',   $s->vget('dc'));
		rank_length('srv_prod', $s->vget('product'));
		rank_length('srv_name', $s->vget('server_name'));
		rank_length('srv_ip4',  $s->vget('server_ip'));
		rank_length('srv_ip6',  $s->vget('server_ipv6_net'));
		
		my $rret = $hetzner->get("reset/$sno");
		#print "reset/$sno: ".Dumper($rret);
		push @resets, $rret->{reset};
	}
	foreach my $r (@resets) {
		#print "reset: ".Dumper($r);
		# see json/hetzner.reset
		my $sno = $r->{server_number};
		if (!defined($sno)) {
			next;
		}
		$stash->{s}->{$sno}->{rtype} = $r->{type};
	}
	my @stboxen = $hetzner->get("storagebox");
	foreach my $sba (@stboxen) {
		foreach my $sbb (@{ $sba }) {
			my $sno = $sbb->{storagebox}->{linked_server};
			$stash->{s}->{$sno}->{stbox} = $sbb->{storagebox};
		}
	}

	my @vswitches = $hetzner->get("vswitch");

	# yes double meaning of srv_no, but spacing for subnets past id's
	# is possible this way
	foreach my $vsa (@vswitches) {
	    foreach my $vs (sort { $a->{id} <=> $b->{id} } @{$vsa}) {
		rank_length('srv_no',   $vs->{id});
	    }
	}
	my @rdns = $hetzner->get("rdns");
	my $subres = $hetzner->get("subnet");

	$snolen  = get_length('srv_no');
	$dclen   = get_length('srv_dc');
	$prodlen = get_length('srv_prod');
	$namlen  = get_length('srv_name');
	$ip4len  = get_length('srv_ip4');
	$ip6len  = get_length('srv_ip6');

	if (0) { # not yet
	$res = $mcli->{hetzner}->get("ip");
	#print Dumper($res);
	# see json/hetzner.ip

	my @ips;
	foreach my $ip (@{$res}) {
		my $thisip = $ip->{ip}->{ip};
		my $srvip = $ip->{ip}->{server_ip};
		$treq .= "&ip[]=$thisip";
		push @{$stash->{ip}->{$srvip}}, $thisip;
		push @ips, $ip->{ip};
	}
	}
	#print Dumper($res);
	# see json/hetzner.subnets
	my $subs = { };
	foreach my $subnet (@{$subres}) {
		#print Dumper($subnet);
		# see json/hetzner.subnet
		rank_length('net_len', $subnet->{subnet}->{ip});
		rank_length('gw_len', $subnet->{subnet}->{gateway});

		my $thissub = $subnet->{subnet}->{ip};
		my $sno = $subnet->{subnet}->{server_number};
		if (defined($sno)) {
			push @{ $stash->{s}->{$sno}->{subnets} },
				$subnet->{subnet};
		}
		my $vsno = $subnet->{subnet}->{vswitch_id};
		if (defined($vsno)) {
			push @{ $stash->{vs}->{$vsno}->{subnets} },
				$subnet->{subnet};
		}
		#my $srvip = $subnet->{subnet}->{server_ip};
		#my $cidr = $subnet->{subnet}->{ip}."/".$subnet->{subnet}->{mask};
		#$treq .= "&subnet[]=".$subnet->{subnet}->{ip};
		$subs->{$thissub} = $subnet->{subnet};
	}
	$netlen = get_length('net_len');
	$gwlen  = get_length('gw_len');

	if (0) {
	print $treq;
	print "\n";
	$res = $mcli->{hetzner}->vget($treq);
	#print Dumper($res);
#$VAR1 = {
#          'traffic' => {
#                         'to' => '2020-11-30',
#                         'type' => 'month',
#                         'data' => {
#                                     '78.46.227.212' => {
#                                                          'sum' => '18.1807',
#                                                          'in' => '11.1033',
#                                                          'out' => '7.0774'
#                                                        },
#                                     '168.119.135.217' => {
#                                                            'sum' => '0.1561',
#                                                            'in' => '0.0903',
#                                                            'out' => '0.0658'
#                                                          },
#                                     '78.46.227.214' => {
#                                                          'in' => '2.8184',
#                                                          'out' => '2.1347',
#                                                          'sum' => '4.9531'
#                                                        },
#                                   },
#                         'from' => '2020-11-01'
#                       }
#        };

	}
	
	printf "%${snolen}s %${prodlen}s %${dclen}s %${namlen}s %10s %${ip4len}s %${ip6len}s %s\n",
	    "Number","Prod","DC", "Name","Paid Till",
	    "IPv4","IPv6",
	    "Traffic";
	foreach my $s (@hservers) {
		my ($ti,$to,$ts);
		if (0) {
			($ti,$to,$ts) = $s->traffic;
			if (!defined($ts)) {
				$ts = 0.0;
			}
		} else {
			($ti,$to,$ts) = (0.0,0.0,0.0);
		}
		my $sno = $s->vget('server_number');
		printf "%${snolen}d %${prodlen}s %${dclen}s %${namlen}s %10s %${ip4len}s %${ip6len}s %f\n",
			$sno,
			$s->vget('product'),
			$s->vget('dc'),
			$s->vget('server_name'),
			$s->vget('paid_until'),
			$s->vget('server_ip'),
			$s->vget('server_ipv6_net'),
			$ts;
		my $stbox = $stash->{s}->{$sno}->{stbox};
		if (defined($stbox)) {
			fmt_stbox($stbox);
		}
		my $nets = $stash->{s}->{$sno}->{subnets};
		if (defined($nets)) {
			fmt_subnets($nets);
		}
		my $resets = $stash->{s}->{$sno}->{rtype};
		if (defined($resets)) {
			fmt_resets($resets);
		}
	}

	status("Hetzner vswitch");
	#print "vswitches:\n",Dumper(@vswitches);
	# see json/hetzner.vswitch
	printf "%5s %4s %s\n",
		"VID", "vlan", "Name";
	foreach my $vsa (@vswitches) {
	    foreach my $vs (sort { $a->{id} <=> $b->{id} } @{$vsa}) {
		printf "%${snolen}s %4s %s\n",
			$vs->{id},
			$vs->{vlan},
			$vs->{name};
		my $nets = $stash->{vs}->{ $vs->{id} }->{subnets};
		if (defined($nets)) {
			fmt_subnets($nets);
		}
	    }
	}

	status("Hetzner rdns");
	#print "rdns:\n",Dumper(@rdns);
	# see json/hetzner.rdns
	foreach my $r1 (@rdns) {
		foreach my $r (@{$r1}) {
			my $d = $r->{rdns};
			rank_length('rip',  $d->{ip});
			rank_length('rptr', $d->{ptr});
		}
	}
	my $riplen  = get_length('rip');
	my $rptrlen = get_length('rptr');
	foreach my $r1 (@rdns) {
		foreach my $r (@{$r1}) {
			printf "%${riplen}s %${rptrlen}s\n",
				$r->{rdns}->{ip},
				$r->{rdns}->{ptr};
		}
	}

	if (0) {
	status("Server Market");
	my $call = "order/server_market/product";
	$call .= "?search=Ent";

	# min_cpu_benchmark
	# cpu    bench
	# i7-920 5005
	# i7-930 5165
	# i7-950 5682
	# i7-960 6012
	# i7-975 6370
	# AMD Opteron 6338P 6853
	my $winner;
	if (!defined($opt_D)) {
		$opt_D = 0;
	}

	my $mins = { };

	my $servers = Hetzner::Servers->new();

	foreach my $name (keys %{$servers}) {
		foreach my $mn (('minmem', 'mincpu', 'mindisk')) {
			if (!defined($mins->{$mn})) {
				$mins->{$mn} = $servers->{$name}->{$mn};
				next;
			}
			if ($mins->{$mn} > $servers->{$name}->{$mn}) {
				$mins->{$mn} = $servers->{$name}->{$mn};
			}
		}
	}

	$call .= "&min_cpu_benchmark=".$mins->{mincpu};
	$call .= "&min_memory_size=".$mins->{minmem};
	my $parsed = $mcli->{hetzner}->get($call);

	hetzner_show_market_list($parsed, $servers);

	foreach my $dc (sort keys %{$stats->{dcs}}) {
		print "\nDC .. ${dc}\n";
		$servers = Hetzner::Servers->new();
		hetzner_show_market_list($parsed, $servers, $dc);
	}
	}


}

sub hetzner_query {
	my ($hetzner) = @_;

	my $q = $opt->{query};
	my $res = $hetzner->get($q);
	print "$q: ".Dumper($res);
	exit(0);
}

sub hetzner_update {
	my ($hetzner) = @_;

	if ($opt->{update} eq "rdns") {
			my $ip  = $opt->{ip};
			my $ptr = $opt->{ptr};
			my $data = { ptr => $ptr };
			my $res = $hetzner->post("rdns/${ip}", $data);
			print "res: ".Dumper($res);
			exit(0);
	}
	exit(0);
}

sub fmt_subnets {
	my ($nets) = @_;

	foreach my $net (@{$nets}) {
		printf "%${snolen}s subnet %${netlen}s/%2d gw %${gwlen}s\n",
			" ", $net->{ip}, $net->{mask}, $net->{gateway};
	}
}

sub fmt_resets {
	my ($resets) = @_;

	printf "%${snolen}s reset types: %s\n", " ", join(",", @{ $resets });
}

sub fmt_stbox {
	my ($stbox) = @_;

	#printf "%${snolen}s stbox %s\n", " ", Dumper($stbox);
	my $prod = $stbox->{product};
	$prod =~ s/\s.*$//;
	my $dc = $stbox->{location};
	my $name = $stbox->{name};
	my $space = $stbox->{product};
	if ($space =~ /^.*\(([0-9]+ [GT]B).*$/) {
		$space = $1;
	}
	printf "%${snolen}s %${prodlen}s %${dclen}s %${namlen}s %10s %${snolen}s %4s %s\n",
		" ", "stbox ".$prod, $dc, $name, $stbox->{paid_until},
		$stbox->{id}, $space, $stbox->{login};
}

sub hetzner_setup {
	use WWW::Hetzner;

	my $hconfig = $r->readconf($ENV{'HOME'}."/.hcli.conf")->{_};

	my $hetzner = WWW::Hetzner->new(
		huser => $hconfig->{huser},
		hpass => $hconfig->{hpass},
	);
	return $hetzner;
}

sub coinbase {
	if (!defined($mcli->{coinbase})) {
		$mcli->{coinbase} = coinbase_setup();
	}
	my $coinbase = $mcli->{coinbase};

	status("Coinbase spot price");

	my ($res) = $coinbase->get_spot_price("USD");
	my $price = $res->{data}->{amount};
	if ($opt_q > 0) {
		print $price;
		return;
	}
	printf "Current bitcoin price in %s: %s\n", "USD", $price;

	my @resp = $coinbase->get_accounts();
	my @accts;
	foreach my $parsed (@resp) {
		if (defined($parsed->{data})) {
			foreach my $k ($parsed->{data}) {
				if (ref($k) eq "ARRAY") {
					foreach my $l (@{$k}) {
						push @accts,$l;
					}
				}
			}
		}
	}
	my $totalusd=0.0;
	foreach my $a (@accts) {
		$totalusd += $a->{native_balance}->{amount};
	}
	my $totalbtc=$totalusd/$price;
	printf "Total in coinbase wallets: %10.8f BTC (%8.3f USD)\n",
		$totalbtc, $totalusd;
}

sub bleutrade_setup {
	return;
	#use WebService::BleuTrade;
	use LWP::UserAgent;

	my $conf = $ENV{'HOME'}."/.bleutrade.conf";
	my $config = $r->readconf($conf)->{_};
	my $key = $config->{key};
	my $ro = $config->{ro};

	my $ua = LWP::UserAgent->new;
	$ua->agent("mcli/0.0 ".$ua->agent);
	$ua->agent("OpenBSD ftp");
	$ua->agent("Mozilla/4.0 (compatible; Bleutrade API perl client)");
	$ua->env_proxy(1);

	my $bt;
	if (defined($key) && defined($ro)) {
		$bt = WebService::BleuTrade->new(
		    ua => $ua,
		    api_key => $key,
		    api_secret => $ro,
		);
	} else {
		$bt = WebService::BleuTrade->new(ua => $ua);
	}
	return $bt;
}

sub coinbase_setup {
	use WebService::CoinBase::v2;

	my @scopes = (
        	"wallet:accounts:read",
        	"wallet:checkouts:read",
        	"wallet:checkouts:create",
        	#"wallet:orders:read",
        	#"wallet:orders:create",
        	"wallet:transactions:read",
        	"wallet:user:read",
	);

	my $scope = "";
	foreach my $s (@scopes) {
        	if (defined($scope)) {
                	$scope .= ",".$s;
        	} else {
                	$scope = $s;
        	}
	}
	my $coinbase = WebService::CoinBase::v2->new(
		scopes => $scope,
	);
	return $coinbase;
}

sub coinbase_order_accts {
	my $res;
	$res = $a->{type} cmp $b->{type};
	if ($res != 0) {
		return $res*-1;
	}
	$res = $a->{currency} cmp $b->{currency};
	if ($res != 0) {
		return $res;
	}
	return $a->{name} cmp $b->{name};
}

sub kraken {
	use Finance::Bank::Kraken;
	if (!defined($mcli->{kraken})) {
		$mcli->{kraken} = kraken_setup();
	}
	my $kraken = $mcli->{kraken};

	if (!defined($opt_a)) {
		$opt_a = "ticker";
	}

	if ($opt_a eq "ticker") {

		status("Kraken spot price");

		my $res = $kraken->call(Public, 'Ticker', ['pair=XBTUSD']);
		my $parsed = parse_json( $res, 'kraken' );

		#print Dumper($parsed);
		my $btc = $parsed->{result}->{XXBTZUSD};
		if (!defined($btc)) {
			print "Oops, btc not found\n";
			return;
		}
		my $bid = $btc->{b}[0];
		my $ask = $btc->{a}[0];
		my $avg = ($bid+$ask)/2;
		if ($opt_q > 0) {
			print $avg;
			return;
		}
		printf "Bid %s\nAsk %s\n", $bid, $ask;
		printf "Avg %s\n", $avg;
		printf "Low %s %s (today 24hrs)\n", $btc->{l}[0], $btc->{l}[1];
		printf "Hi  %s %s (today 24hrs)\n", $btc->{h}[0], $btc->{h}[1];
		printf "Vol %s %s (today 24hrs)\n", $btc->{v}[0], $btc->{v}[1];
		printf "Wav %s %s (today 24hrs)\n", $btc->{p}[0], $btc->{p}[1];
		printf "Lst %s %s (price volume)\n", $btc->{c}[0], $btc->{c}[1];
	}
	if ($opt_a eq "assets") {
		my $res = $kraken->call(Public, 'Assets');
		my $parsed = parse_json( $res, 'kraken' );
		foreach my $asset (sort keys %{$parsed->{result}}) {
			my $r = $parsed->{result}->{$asset};
			printf "%4s %4s %8s %2d %2d\n", $asset, $r->{altname},
			    $r->{aclass}, $r->{decimals},
			    $r->{display_decimals};
		}
		#print Dumper($parsed);
	}
	if ($opt_a eq "assetpairs") {
		my $res = $kraken->call(Public, 'AssetPairs');
		my $parsed = parse_json( $res, 'kraken' );
		foreach my $pair (sort keys %{$parsed->{result}}) {
			my $r = $parsed->{result}->{$pair};
			printf "%11s %11s %8s %4s %4s\n", $pair, $r->{altname},
			    $r->{aclass_base}, $r->{base}, $r->{quote};
		}
		#print Dumper($parsed);
	}
		
}

sub kraken_setup {
	use Finance::Bank::Kraken;
	use JSON;
	if (!defined($mcli->{JSON})) {
		$mcli->{JSON} = JSON->new->allow_nonref;
	}

	my $kraken = Finance::Bank::Kraken->new;
	return $kraken;
}

sub bitstamp {
	#use Finance::BitStamp::API;
	if (!defined($mcli->{bitstamp})) {
		$mcli->{bitstamp} = bitstamp_setup();
	}
	my $bitstamp = $mcli->{bitstamp};

	status("BitStamp spot price");

	my $res = $bitstamp->ticker;
	#print Dumper($res);
	#my $parsed = parse_json( $res, 'kraken' );

	#print Dumper($parsed);
	my $bid = $res->{bid};
	my $ask = $res->{ask};
	my $avg = ($bid+$ask)/2;
	if ($opt_q > 0) {
		print $avg;
		return;
	}
	printf "Bid %s\nAsk %s\n", $bid, $ask;
	printf "Avg %s\n", $avg;
	printf "Low %s\n", $res->{low};
	printf "Hi  %s\n", $res->{high};
	printf "Vol %s\n", $res->{volume};
}

sub bitstamp_setup {
	use Finance::BitStamp::API;
	use JSON;
	if (!defined($mcli->{JSON})) {
		$mcli->{JSON} = JSON->new->allow_nonref;
	}

	my $bitstamp = Finance::BitStamp::API->new;
	return $bitstamp;
}

sub bci {
	if (!defined($mcli->{bci})) {
		$mcli->{bci} = bci_setup();
	}
	my $bci = $mcli->{bci};
	$bci->ua->agent("OpenBSD ftp");

	if (defined($opt_a) && $opt_a eq "rawtx" && defined($opt_t)) {
		my $rawtx = $bci->rawtx($opt_t);
		print Dumper($rawtx);
		return;
	}
		
	status("BlockChain.info lastblock");

	my $res = $bci->latestblock;

	my $hash = $res->{hash};
	my @txi = @{$res->{txIndexes}};
	my $block_index = $res->{block_index};
	my $time = $res->{time};
	my $height = $res->{height};
	if ($opt_q > 0) {
		print $height;
		return;
	}
	printf "%s %d %s\n", strftime("%Y%m%d %H:%M:%S",localtime($time)),
	    $height, $hash;
}

sub bci_setup {
	use WebService::BlockChain::Info;
	use JSON;
	if (!defined($mcli->{JSON})) {
		$mcli->{JSON} = JSON->new->allow_nonref;
	}

	my $bci = WebService::BlockChain::Info->new;
	return $bci;
}
sub bw {
	if (!defined($mcli->{bw})) {
		$mcli->{bw} = bw_setup();
	}
	my $bw = $mcli->{bw};
	$bw->ua->agent("OpenBSD ftp");

	status("bw.com account info");

	my $res = $bw->account;
	print Dumper($res);
}

sub bw_setup {
	use WebService::BW;
	use JSON;
	if (!defined($mcli->{JSON})) {
		$mcli->{JSON} = JSON->new->allow_nonref;
	}

	my $conf = $ENV{'HOME'}."/.bw.conf";
	my $config = $r->readconf($conf)->{_};
	my $key = $config->{key};
	my $sec = $config->{sec};
	my $user = $config->{user};

	my $bw = WebService::BW->new( api_key => $key, api_secret => $sec,
		userName => $user );

	return $bw;
}

sub namecheap {
	if (!defined($mcli->{namecheap})) {
		$mcli->{namecheap} = namecheap_setup();
	}
	my $namecheap = $mcli->{namecheap};

	status("Namecheap domain");

	my $dns = $namecheap->dns();
	#print STDERR "DNS:\n".Dumper($dns);

	if (defined($opt_a) && $opt_a =~ /^set ns=(.*)$/) {
		my @nslist = split(/,/,$1);
		foreach my $ns (@nslist) {
			print "+ns  ${ns}\n";
		}
		foreach my $dom (@ARGV) {
			print "+dom ${dom}\n";
			my $result = $dns->setnameservers({
				DomainName => $dom,
				Nameservers => [ @nslist ],
				DefaultNS => 0,
			});
			if (defined($result)) {
				print "Result of setting ${dom} ns:\n";
				print Dumper($result);
			} else {
				print "Failed to set ${dom} ns\n";
			}
		}
	}
	my $domlist = $dns->getdomains(PageSize => 30);
	#print STDERR "DOMLIST:\n".Dumper($domlist);
	my $wg = $namecheap->wg();
	#print STDERR "WG:\n".Dumper($wg);
	my $pricing = $namecheap->pricing();
	#print STDERR "pricing:\n".Dumper($pricing);
	my $NS = $namecheap->ns();


#   $VAR1 = {
#          'ProductType' => {
#                           'Name' => 'domains',
#                           'ProductCategory' => {
#                                                'Product' => {
#                                                             'Name' => 'com',
#                                                             'Price' => [
#                                                                        {
#                                                                          'AdditionalCost' => '0.18',
#                                                                          'PromotionPrice' => '0.0',
#                                                                          'YourAdditonalCost' => '0.18',
#                                                                          'RegularPriceType' => 'MULTIPLE',
#                                                                          'YourPrice' => '12.98',
#                                                                          'RegularAdditionalCost' => '0.18',
#                                                                          'RegularPrice' => '12.98',
#                                                                          'DurationType' => 'YEAR',
#                                                                          'YourPriceType' => 'MULTIPLE',
#                                                                          'RegularAdditionalCostType' => 'MULTIPLE',
#                                                                          'Currency' => 'USD',
#                                                                          'Duration' => '1',
#                                                                          'Price' => '12.98',
#                                                                          'YourAdditonalCostType' => 'MULTIPLE',
#                                                                          'PricingType' => 'MULTIPLE'
#                                                                        },

	my $prices = { };

	my %whoisguard;
	my $wglist = $wg->getList();
	if (ref($wglist->{Whoisguard}) eq "HASH") {
		# $VAR1 = {
          	#	'Whoisguard' => {
                #            'Expires' => '04/15/2020',
                #            'ID' => '29431022',
                #            'DomainName' => 'freedaemonconsulting.com',
                #            'Status' => 'enabled',
                #            'Created' => '04/22/2019'
                #          }
        	# };
		my $wgldn = $wglist->{WhoisGuard}->{DomainName};
		if (defined($wgldn)) {
			$whoisguard{$wgldn} = $wglist->{WhoisGuard};
		}
	} elsif (ref($wglist->{Whoisguard}) eq "ARRAY reference") {
		foreach my $w (@{$wglist->{Whoisguard}}) {
			my %i = %{$w};
			my $dom = $i{DomainName};
			$whoisguard{$dom} = $w;
		}
	} else {
		# if nobody has a whoisguard entry its empty???
		#print "wg->getList() returned a ".ref($wglist->{Whoisguard})."\n";
		#print Dumper($wglist);
		#exit(1);
	}
		

	foreach my $dd (@{$domlist->{Domain}}) {
		my %d = %{$dd};
		my $dom = $d{'Name'};
		$dd->{ExpiresUD} = UnixDate(ParseDate($dd->{Expires}),"%s");
		my $tld;
		if ($dom =~ /^.*\.([^\.]+)$/) {
			$tld = lc($1);
		} else {
			print STDERR "dom $dom has no tld???\n";
			next;
		}
		if (defined($prices->{$tld})) {
			if ($opt_v > 0) {
			    print "prices->{$tld} = ".$prices->{$tld}."\n";
			}
			next;
		}
	   	my $pret = $pricing->getpricing(ProductType => 'DOMAIN', ActionName => 'RENEW',
		    ProductName => uc($tld));
		#print "getpricing(ProductType => 'DOMAIN', ActionName => 'RENEW', ProductName => ".uc($tld);
		#print ") = ";
		#print Dumper($pret);
		#print "\n";
	   	foreach my $price (@{ $pret->{ProductType}->{ProductCategory}->{Product}->{Price} }) {
		    my $pname = $pret->{ProductType}->{ProductCategory}->{Product}->{Name};
		    my $cost = $price->{YourPrice};
		    my $curr = $price->{Currency};
		    if ($opt_v > 0) {
		    	printf "'%s' costs %s %s to renew @ %d %s\n", $pname, $cost, $curr,
			    $price->{Duration}, $price->{DurationType};
		    }
		    if ($price->{DurationType} eq 'YEAR' &&
			$price->{Duration} == 1) {
				$prices->{$tld} = $cost;
		    }
	        }
	}

	printf "%9s %10s %10s %5s %2s %2s %2s %2s %2s %2s %8s %s\n", "ID", "Created", "Expires", "InDays",
	    "AR", "EX", "LO", "OD", "PR", "WG",
	    "Cost",
	    "Domain name";

	my $tcost = 0.0;
	foreach my $dd (sort { $a->{ExpiresUD} <=> $b->{ExpiresUD} } @{$domlist->{Domain}}) {
		my %d = %{$dd};
		my $dom = $d{'Name'};
		#my $flags="";
		my ($ar,$ex,$lo,$prem,$our,$wg)=(1,1,1,1,1,1);
		if (defined($whoisguard{$dom})) {
			if ($whoisguard{$dom}{Status} eq "disabled") {
				$wg = 0;
			}
			#$flags=add_str_list($flags,"WG$wg");
		} else {
			$wg = 0;
		}
		if ($d{'AutoRenew'} eq 'false') {
			$ar = 0;
		}
		if ($d{'IsExpired'} eq 'false') {
			$ex = 0;
		}
		if ($d{'IsOurDNS'} eq 'false') {
			$our = 0;
		}
		if ($d{'IsLocked'} eq 'false') {
			$lo = 0;
		}
		if ($d{'IsPremium'} eq 'false') {
			$prem = 0;
		}

		#$flags = add_str_list($flags, "AR$ar");
		#$flags = add_str_list($flags, "EX$ex");
		#$flags = add_str_list($flags, "LO$lo");
		#$flags = add_str_list($flags, "OD$our");
		#$flags = add_str_list($flags, "PR$prem");

		my $tld = "...error...";
		if ($d{Name} =~ /^.*\.([^\.]+)$/) {
			$tld = $1;
		}
		my $cost = 0.0;
		if (defined($prices->{$tld})) {
			$cost = $prices->{$tld};
		}
		my $date1 = $dnow;
		my $date2 = Date::Manip::Date->new($d{Expires});
		my $delta = $date1->calc($date2);
		my $indays = $delta->printf("%.1dhm");

		#printf STDERR " [%s]\n", $flags;
		printf "%9d %10s %10s %5.1f %2d %2d %2d %2d %2d %2d \$%7.2f %s\n",
		    $d{'ID'}, $d{'Created'}, $d{'Expires'}, $indays,
		    $ar, $ex, $lo, $our, $prem, $wg,
		    $cost,
		    $dom;
		$tcost += $cost;
		my $hosts = $dns->gethosts(DomainName => $dom);
		if (defined($hosts)) {
			foreach my $h (@{$hosts->{Host}}) {
				#print Dumper($h);
				#last;
				printf "\t%9d %10s %5d %s %s\n",
					$h->{HostId},
					$h->{Name},
					$h->{TTL},
					$h->{Type},
					$h->{Address};
			}
			#print STDERR Dumper($hosts);
		}
		if ($opt_q > 0) {
		my $nameservers = $dns->getnameservers(DomainName => $dom);
		if (defined($nameservers)) {
			printf "%10s nameservers = {","";
			my $nstr="";
			foreach my $ns (sort @{$nameservers->{Nameserver}}) {
				$nstr .= $ns;
				#my $nsinfo = $NS->getInfo({
				#	Nameserver => $ns,
				#});
				#if (defined($nsinfo)) {
				#  print "ns.getInfo '${ns}':\n".Dumper($nsinfo);
				#  $nstr .= " ".$nsinfo->{IP};
				#  
				#}
				#exit(0);
				$nstr .= ", ";
			}
			$nstr =~ s/, $//;
			print $nstr."}\n";
			#print Dumper($nameservers);
		}
		}
	}
	printf "%56s\$%7.2f\n", " ", $tcost;
}

sub namecheap_setup {
	my $namecheap;

	use WWW::Namecheap::API;

	my $nconf = $ENV{'HOME'}."/.namecheap.conf";
	my $nconfig = $r->readconf($nconf)->{_};

	my $napiuser=$nconfig->{'apiuser'};
	my $napikey=$nconfig->{'apikey'};

	if (!defined($napiuser) || !defined($napikey)) {
		die "napiuser and napikey must be defined in the config file: $nconf";
	}

	$namecheap = WWW::Namecheap::API->new(
		#System => 'test',
		System => 'prod',
		ApiUser => $napiuser,
		ApiKey => $napikey,
		DefaultIp => $nconfig->{'defaultip'},
	);
	return $namecheap;
}

sub weather_timefmt {
	my ($str) = @_;
	if (!defined($str)) {
		return "<str:undef>";
	}
	my $date = Date::Manip::Date->new();
	if ($str =~ /^([0-9]+:[0-9]+ [AP]M) ([A-Z]+) on (.*)$/) {
		$date->parse_date($3);
		$date->parse_time($1);
		return $date->printf("%Y%m%d %H:%M:%S");
		$str = "$3 $1";
	}
	$date->parse($str);
	return $date->printf("%Y%m%d %H:%M:%S");
}

sub weather_history {
	my ($weather, $date) = @_;

	my $history = $weather->api_call("history_${date}");
	my $sum = $history->{dailysummary};
	foreach my $e (@$sum) {
		printf "%s %3d/%3d\n",
		    weather_timefmt($history->{date}{pretty}),
		    $$e{maxtempi}, $$e{mintempi};
	}
	#      20170829 18:53:00 81.00  29.97 10.4  44% 0 0 0 Remarks
	print "  Date     Time   Temp   Press wspd  hum rain/hail/snow Remarks\n";
	foreach my $o (@{$history->{observations}}) {
		my $w = { };
		foreach my $wt (("rain","snow","hail")) {
			if (!defined($$o{$wt})) {
				$w->{$wt} = 0;
				next;
			}
			if ($$o{$wt} eq "N/A") {
				$w->{$wt} = 0;
				next;
			}
			$w->{$wt} = $$o{$wt};
		}
		$w->{fmt}->{tempi}->{std} = "%4.2f";
		$w->{fmt}->{tempi}->{na} = "%5s";
		$w->{fmt}->{hum}->{std} = "%3d%%";
		$w->{fmt}->{hum}->{na} = "%4s";
		my $na = 'n/a';
		foreach my $wt (("tempi","hum")) {
			if (!defined($$o{$wt})) {
				$w->{$wt} = sprintf $w->{fmt}->{$wt}->{na},$na;
				next;
			}
			if ($$o{$wt} =~ /n\/a/i) {
				$w->{$wt} = sprintf $w->{fmt}->{$wt}->{na},$na;
				next;
			}
			if ($$o{$wt} == -9999.0) {
				$w->{$wt} = sprintf $w->{fmt}->{$wt}->{na},$na;
				next;
			}
			$w->{$wt} = sprintf $w->{fmt}->{$wt}->{std}, $$o{$wt};
		}
		my $metar = $$o{metar};
		my $rmk;
		if ($metar =~ /.* RMK (.*)$/) {
			$rmk = $1;
		} else {
			$rmk = "";
		}
		printf "%s %5s %6.2f %4.1f %4s %s %s %s %s\n",
		    weather_timefmt($$o{date}{pretty}),
		    $w->{tempi}, $$o{pressurei}, $$o{wspdi}, $w->{hum},
		    $w->{rain}, $w->{hail}, $w->{snow}, $rmk;
		#if ($$o{tempi} == -9999.00) {
		#	print Dumper($o);
		#}
	}
	#print Dumper($history);
	return;
}

sub weather {
	if (!defined($mcli->{weather})) {
		$mcli->{weather} = weather_setup();
	}
	#use Temperature::Windchill qw{ windchill_us };

	my $weather = $mcli->{weather};

	if (defined($opt_H)) {
		weather_history($weather, $opt_H);
		return;
	}
	
	my $astro = $weather->astronomy;
	my $times = { };
	if (defined($astro)) {
		foreach my $sm (("sun","moon")) {
			foreach my $rs (("rise","set")) {
				my $time;
				my $op = ${sm}.${rs};
				eval {
			    		$time = $astro->$op;
				};
				if ($@) {
					print "Hmm: $@\n";
				}
				if (defined($time)) {
					$times->{$sm}->{$rs} =
					    sprintf("%02d:%02d",
					    $time->hour, $time->minute);
				} else {
					$times->{$sm}->{$rs} = "undef";
				}
			}
		}

		printf("Sun/Moon rise->set %s->%s / %s->%s\n",
			$times->{sun}->{rise}, $times->{sun}->{set},
			$times->{moon}->{rise}, $times->{moon}->{set},
		);
	} else {
		printf "astro %s { sunrise = %s, sunset = %s, moonrise = %s, ".
		    "moonset = %s}\n", $astro, $astro->sunrise, $astro->sunset,
		    $astro->moonrise, $astro->moonset;
	}

	my $forecast = $weather->forecast;
	#print Dumper($forecast);

	printf("Temp(F) %4.1f :", $weather->temp_f);
	my @hourly = @{ $weather->hourly };
	my $lines = weather_init_lines();
	$lines->{topline} = "";
	my $hcount = 0;
	my $lastr;
	foreach my $r (@hourly) {
		my $t = $r->{temp}{english};
		my $ws = $r->{wspd}{english};
		my $rh = $r->{humidity};
		$lines->{topline} .= sprintf(" %3d", $r->{FCTTIME}{hour_padded});
		$lines->{infline} .= sprintf(" %3d", $t);
		my $wch = calc_real_feel($r);
		$lines->{feeline} .= sprintf(" %3d", $wch);
		$lines->{spdline} .= sprintf(" %3d", $ws);
		$lines->{humline} .= sprintf(" %3d", $rh);
		$lines->{qpfline} .= sprintf(" %3.1f", $r->{qpf}{english});
		if ($hcount++ > 11) {
			$hcount = 0;
			print $lines->{topline}."\n";
			print $lines->{infline}."\n";
			print $lines->{spdline}."\n";
			print $lines->{feeline}."\n";
			print $lines->{humline}."\n";
			print $lines->{qpfline}."\n";
			print "\n";
			$lines = weather_init_lines();
		}
		$lastr = $r;
	}
	print "\n";
	#print Dumper($lastr);

	my $forecast10 = $weather->forecast10day;
	my $lastday;
	#print Dumper($forecast10);
	#     "Jan 16, 2018   17/   6 15/ 9    5/ -11  41    0  0.00 Clear";
	print "                Temp    Wind  RealFeel      POP  Rain\n";
	print "    Date       Hi/  Lo Hi/Lo   Hi/ Lo Humid.  %  (in) Conditions\n";
	foreach my $day (@{$forecast10->{simpleforecast}->{forecastday}}) {
		my $maxwind = $day->{maxwind}->{mph};
		my $avgwind = $day->{avewind}->{mph};
		my $lowwind = ( $avgwind * 2 ) - $maxwind;
		my $high = $day->{high}->{fahrenheit};
		my $low = $day->{low}->{fahrenheit};
		my $hum = $day->{avehumidity},
		my $wchi;
		my $wclo;

		my $myr = faker( $high, $lowwind, $hum );
		$wchi = calc_real_feel( $myr );
		$myr = faker( $low, $maxwind, $hum );
		$wclo = calc_real_feel( $myr );
		printf "%3s %2s, %4s %4d/%4d %2d/%2d %4d/%4d %3d %4i %5.2f %-s\n",
			$day->{date}->{monthname_short},
			$day->{date}->{day},
			$day->{date}->{year},
			$high, $low,
			$maxwind, $lowwind,
			$wchi, $wclo,
			$day->{avehumidity},
			$day->{pop},
			$day->{qpf_allday}{in},
			$day->{conditions};
		$lastday = $day;
		#print Dumper($lastday);
	}
	#print Dumper($lastday);
	#print Dumper($weather->data);
}

sub faker {
	my ($t, $wspd, $hum) = @_;

	my $myr = { };
	$myr->{temp}{english} = $t;
	$myr->{wspd}{english} = $wspd;
	$myr->{humidity} = $hum;
	$myr->{windchill}{english} = $t;
	$myr->{feelslike}{english} = $t;
	$myr->{heatindex}{english} = $t;

	return $myr;
}
sub calc_real_feel {
	my ($r) = @_;
	my $t = $r->{temp}{english};
	my $ws = $r->{wspd}{english};
	my $rh = $r->{humidity};
	my $wch = $t;
	my $rwc = $r->{windchill}{english};
	my $rfl = $r->{feelslike}{english};
	my $rhi = $r->{heatindex}{english};

	my ($mywc,$myhi,$myrf) = ($t, $t, $t);

	if ($rfl == -9999) {
		$rfl = $t;
	}
	if ($rwc == -9999) {
		$rwc = $rfl;
	}
	if ($rhi == -9999) {
		$rhi = $rfl;
	}
	if ($t <= 50) {
		$mywc = windchill_us($t, $ws);
		$myrf = $mywc;
	} else {
		$myhi = heatindex( $wch, $rh);
		$myrf = $myhi;
	}
	if ($mywc != $rwc && $opt_v > 0) {
		printf "calc_feels_like: mywc != rwc .. t/mywc/rwc=%s/%s/%s\n", $t,$mywc,$rwc;
	}
	if ($myhi != $rhi && $opt_v > 0) {
		printf "calc_feels_like: myhi != rhi .. t/myhi/rhi=%s/%s/%s\n", $t,$myhi,$rhi;
	}
	if ($opt_v > 0) {
		printf "calc_real_feel: results t/rwc/rfl/rhi/mywc/myhi/myrf = ".
		    "%s/%s/%s/%s/%s/%s/%s\n", $t, $rwc, $rfl, $rhi, $mywc, $myhi, $myrf;
	}
	return $myrf;
}

sub windchill_us {
	my ($temp, $ws) = @_;
	if (!defined($temp) || !defined($ws)) {
		return $temp;
	}
	if ($ws < 3) {
		return $temp;
	}
	if ($temp > 50 || $temp < -50) {
		return $temp;
	}
	my $pow = $ws ** 0.16;
	my $wc = 35.74 + (0.6215 * $temp) - (35.75 * $pow) + (0.4275 * $temp * $pow);
	return $wc;
}

sub heatindex {
	my ($t, $rh) = @_;
	# taken from http://www.wpc.ncep.noaa.gov/html/heatindex_equation.shtml

	if ($t <= 50) {
		return $t;
	}

	my ($adjustment,$hi);
	if ($rh < 13 && $t >= 80 && $t <= 112) {
		$adjustment = ( (13-$rh)/4)*sqrt( (17-abs($t-95))/17 );
		$adjustment *= -1;
	}
	if ($rh > 85 && $t >= 80 && $t <= 87) {
		$adjustment = ( ($rh-85)/10 ) * ( (87-$t)/5 );
	}
	$hi = 0.5 * ($t + 61.0 + ( ($t-68.0)*1.2) + ($rh*0.094) );

	if ( ($hi+$t)/2 < 80 ) {
		return $hi;
	}

	$hi = -42.379 + 2.04901523*$t + 10.14333127*$rh - .22475541*$t*$rh -
		.00683783*$t*$t - .05481717*$rh*$rh + .00122874*$t*$t*$rh +
		.00085282*$t*$rh*$rh - .00000199*$t*$t*$rh*$rh;
	if (defined($adjustment)) {
		$hi += $adjustment;
	}
}


sub weather_setup {
	#use WWW::Wunderground::API;
	use Cache::FileCache;

	my $conf = $opt_c;
	if (!defined($conf)) {
		$conf = $ENV{'HOME'}."/.weather.conf";
	}

	my ($apikey, $location);
	my $allconf = $r->readconf($conf);
	if (defined($opt_a) && defined($allconf->{$opt_a})) {
		$location = $allconf->{$opt_a}->{location};
		$apikey = $allconf->{$opt_a}->{api_key};
	}
	if (!defined($apikey)) {
		$apikey = $allconf->{_}->{api_key};
	}
	if (!defined($location)) {
		$location = $allconf->{_}->{location};
	}
	if (!defined($apikey)) {
		print "api_key is not defined, bailing\n";
		return undef;
	}
	if (!defined($location)) {
		print "location is not defined, bailing\n";
		return undef;
	}
	my $wu; # = WWW::Wunderground::API->new(
	#	location => $location,
	#	api_key => $apikey,
	#	auto_api => 1,
	#	cache => Cache::FileCache->new({
	#		namespace => 'weathercache',
	#		default_expires_in => 2400,
	#	}),
	#);

	return $wu;
}

sub voipms {
	if (!defined($mcli->{voipms})) {
		$mcli->{voipms} = voipms_setup();
	}
	my $voip = $mcli->{voipms};

	status("Voip.ms infoz");

	print "Balance: ";
	my $balinfo= $voip->getBalance();
	my $fmt = "%0.4f\n";
	printf $fmt, $balinfo;

	my $res = $voip->getCallAccounts;
	printf "%3s %12s %3s %s\n",
		"ID","Value","Reg","Host";
	my $count = 1;
	foreach my $acct (@{$res}) {
		if ($acct->{value} eq "all") {
			next;
		}
		printf "%2d. %-12s", $count++, $acct->{value};
		my $res2 = $voip->getRegistrationStatus(account => $acct->{value});
		my $regs = "";
		foreach my $r (@{$res2->{registrations}}) {
			$regs .= $r->{server_hostname}.",";
		}
		$regs =~ s/,$//;
		printf " %3s %s\n", $res2->{registered}, $regs;
	}
}

sub voipms_setup {
	use VOIP::MS;

	my $vconfig = $r->readconf($ENV{'HOME'}."/.voipms.conf")->{_};
	if (!defined($vconfig->{user}) || !defined($vconfig->{pass})) {
		print "User or Pass is Null and void, bailing for now\n";
		return undef;
	}
	my $voip = VOIP::MS->new(
		username => $vconfig->{user},
		password => $vconfig->{pass},
	);
	return $voip;
}


sub c1360 {
	if (!defined($mcli->{c1360})) {
		$mcli->{c1360} = c1360_setup();
	}
	my $ofx = $mcli->{c1360};
	my $fi = $mcli->{c1360_fi};
	my $url = $mcli->{c1360_url};
	my $fid = $mcli->{c1360_fid};

	status("CapitalOne360");

	my @accounts = $ofx->accounts;
	if (! @accounts) {
		printf "Something went wrong: %s\n", $ofx->response;
		return;
	}
	#print "Seems ok so far:\n";
	my $status = $ofx->response->signon_status_code( $fi );
	if (defined($status)) {
		if ($status != 0) {
			printf "Signon status code: %s\n", $status;
		}
	}

	# 1179955919 150002.02 140002.02 CHECKING ING Medical Fund
	print "    Account Available    Ledger\n";
	print "     Number   Balance   Balance     Type Name\n";
	my $afmt = "%11d %9.2f %9.2f %8s %s\n";

	my $totalbalance=0.0;
	foreach my $acct (@accounts) {
		if (!defined($acct)) {
			next;
		}
		if (ref($acct) eq "") {
			printf "Account is not a hash: %s\n", $acct;
			next;
		}
		my $id = $acct->{acctid};
		my $type = $acct->{accttype};
		my $desc = $acct->{desc};
		my $acct_obj = Finance::OFX::Account->new(
			URL => $url,
			Type => $type,
			ID => $id,
			FID => $fid
		);
		my $now = time();
		my $start = $now - 90*3600*24;
		my $txyn = 'Y';
		if ($opt_q == 1) {
			$txyn = 'N';
		}
		my $r = $ofx->{ua}->statement($acct_obj, start=> $start, end=> $now, transactions => 'Y');
		if (! $r->is_success) {
			print "Failure???\n";
		}
		if ($r->signon_status_code) {
			print "Status code ??\n";
		}
		my $trans = $r->ofx->{bankmsgsrsv1}{stmttrnrs};
		my $availbal = $trans->{stmtrs}->{availbal}->{balamt};
		my $ledgerbal = $trans->{stmtrs}->{ledgerbal}->{balamt};
		printf $afmt, $id, $availbal, $ledgerbal, $type, $desc;
		$totalbalance += $ledgerbal;

		# skip tx bits if quiet is asked for
		if ($opt_q == 1) {
			next;
		}
		my $ofxres = $r->ofx;
		if (! $ofxres->{bankmsgsrsv1}{stmttrnrs}{stmtrs}) {
			print "No transactions\n";
			next;
		}
		my $transaction = $ofxres->{bankmsgsrsv1}{stmttrnrs};
		if (Finance::OFX::transactionStatusCode($transaction)) {
			print "Statement request error: ".($transaction->{status}{message})."\n";
			next;
		}
		#print Dumper($transaction);
		my $txlist = $transaction->{stmtrs}{banktranlist};
		if (!defined($txlist)) {
			next;
		}
		#print Dumper($txlist);
		if (ref($txlist->{stmttrn}) eq "HASH") {
			c1360_fmt_tx($txlist->{stmttrn});
			next;
		}
		if (ref($txlist->{stmttrn}) ne "ARRAY") {
			printf "txlist->{stmttrn} is a %s\n", ref($txlist->{stmttrn});
			print Dumper($txlist->{stmttrn});
			next;
		}
		my @txs = @{$txlist->{stmttrn}};
		foreach my $tx (sort { $a->{dtposted} <=> $b->{dtposted} } @txs) {
			c1360_fmt_tx($tx);
		}
	}
	printf $afmt, 0, 0.0, $totalbalance, "", "Total";
}

sub c1360_fmt_tx {
	my ($tx) = @_;
	my $date = strftime("%Y%m%d %H:%M:%S",localtime($tx->{dtposted}));
	printf "      %4d %s %9.2f %s\n", $tx->{fitid}, $date, $tx->{trnamt}, $tx->{name};
}

sub c1360_setup {
	use Finance::OFX;
	use Finance::OFX::Institution;
	use Finance::OFX::Account;

	my ($org,$fid,$url,$user,$pass);
	my $config = $r->readconf( $ENV{'HOME'}."/.ofxcli.conf" )->{_};

	$org=$config->{org};
	$fid=$config->{fid};
	$url=$config->{url};
	$user=$config->{user};
	$pass=$config->{pass};

	my $fi = Finance::OFX::Institution->new(ORG=>$org, FID=>$fid, URL=>$url);
	my $ofx = Finance::OFX->new(
		userID=>$user,
		userPass=>$pass,
		Institution=>$fi,
		ssl_opts => {
			# XXX without this, we don't like the cert somehow!!!
			verify_hostname => 0,
		},
	);
	$mcli->{c1360_fi} = $fi;
	$mcli->{c1360_url} = $url;
	$mcli->{c1360_fid} = $fid;
	return $ofx;
}

sub parse_json {
	my ($str,$name) = @_;

	my $parsed;
	eval {
		$parsed = $mcli->{JSON}->decode( $str );
	};
	if ($@) {
		die("%s: json->decode('%s') Error %s\n", $name, $str, $@);
		return undef;
	}
	if ($opt_v > 0) {
		printf "Pretty %s: %s\n", $name, $mcli->{JSON}->pretty->encode( $parsed )."\n";;
	}
	return $parsed;
}

sub btcheckret {
	my ($call, $ret) = @_;
	if ($ret->{success} eq "true") {
		return $ret;
	}
	printf "bluetrade %s: %s\n", $call, $ret->{message};
	return undef;
}

sub bleutrade {
	if (!defined($mcli->{bleutrade})) {
		$mcli->{bleutrade} = bleutrade_setup();
	}
	my $bt = $mcli->{bleutrade};

	my $ret;
	foreach my $a (split(/,/,$opt_a)) {
	    if ($a =~ /depositaddr:([A-Z]+)/) {
		my $coin = $1;
		status("BlueTrade Deposit Addr for $coin");

		$ret = btcheckret('depositaddr',$bt->getdepositaddress($coin));
		if (!defined($ret)) {
			next;
		}

		my $addr = $ret->{result}->{Address};
		my $rcoin = $ret->{result}->{Currency};
		if (defined($addr)) {
			printf "%5s %s\n", $rcoin, $addr;
		}

		#print Dumper($bal);
		next;
	    } elsif ($a eq "ticker") {
		status("BleuTrade Ticker");
		while (1) {
		my $totalbalance=0.0;
		$ret = btcheckret('getbalances',$bt->getbalances);
		if (!defined($ret)) {
			next;
		}
		my $rmk = btcheckret('markets',$bt->getmarketsummaries);
		if (!defined($rmk)) {
			next;
		}

		my $str = "";
		foreach my $cur (@{$ret->{result}}) {
			my $addr = $cur->{CryptoAddress};
			if (!defined($addr)) {
				$addr = "<undef>";
			}
			my $currency = $cur->{Currency};
			my $btcrate = 0.0;
			if ($currency eq "BTC") {
				$btcrate = 1.0;
			} else {
			    foreach my $m (@{$rmk->{result}}) {
				if ($m->{MarketName} eq "${currency}_BTC") {
					$btcrate = $m->{Average};
					last;
				}
			    }
			}
			my $btcequiv = 0.0;
			if (defined($btcrate)) {
				$btcequiv = $cur->{Balance} * $btcrate;
			} else {
				$btcrate = 0.0;
			}
			if ($cur->{Balance} == 0.0) {
				next;
			}
			
			$str .= sprintf "%s=%.8f,%d/",
			    $cur->{Currency}, $cur->{Balance},
			    $btcrate * 100000000;
			$totalbalance += $btcequiv;
		}
		$str =~ s/\/$//;
		$str .= sprintf " %.8fBTC\n", $totalbalance;
		print $str;
		sleep(600);
		}
		next;
	    } elsif ($a eq "balances") {
		my $totalbalance=0.0;

		status("BlueTrade Balances");

		$ret = btcheckret('getbalances',$bt->getbalances);
		if (!defined($ret)) {
			next;
		}
		my $rmk = btcheckret('markets',$bt->getmarketsummaries);
		if (!defined($rmk)) {
			next;
		}

		printf "%5s %15s %15s %15s %15s %15s %s\n",
			"Curr.","Balance", "X/BTC", "BTC", "Available", "Pending",
			"Deposit Address";
		foreach my $cur (@{$ret->{result}}) {
			my $addr = $cur->{CryptoAddress};
			if (!defined($addr)) {
				$addr = "<undef>";
			}
			my $currency = $cur->{Currency};
			my $btcrate = 0.0;
			if ($currency eq "BTC") {
				$btcrate = 1.0;
			} else {
			    foreach my $m (@{$rmk->{result}}) {
				#print "comparing ${currency}_BTC to ".$m->{MarketName}."\n";
				if ($m->{MarketName} eq "${currency}_BTC") {
					$btcrate = $m->{Average};
					last;
				}
			    }
			}
			#print "btcrate = $btcrate\n";
			my $btcequiv = 0.0;
			if (defined($btcrate)) {
				$btcequiv = $cur->{Balance} * $btcrate;
			} else {
				$btcrate = 0.0;
			}
			
			printf "%5s %15.8f %15.8f %15.8f %15.8f %15.8f %s\n",
			    $cur->{Currency}, $cur->{Balance}, $btcrate, $btcequiv,
			    $cur->{Available}, $cur->{Pending}, $addr;
			$totalbalance += $btcequiv;
		}
		printf "%5s %15.8f %15.8f %15.8f\n", "Total", $totalbalance, $totalbalance, $totalbalance;

		#print Dumper($ret);
		next;
	    } elsif ($a eq "getorders") {
		$ret = btcheckret('getorders',$bt->getorders(undef,'OK'));
		if (!defined($ret)) {
			next;
		}
		printf "%8s %19s %6s %4s %9s %12s %12s %12s %12s\n",
			"Orderid", "Created", "Status", "Type", "Exchange", "Remains",
			"Price", "Quantity", "QBaseTrade";
		foreach my $o (@{$ret->{result}}) {
			printf "%8d %19s %6s %4s %9s %12.8f %12.8f %12.8f %12.8f\n",
				$o->{OrderId},
				$o->{Created},
				$o->{Status},
				$o->{Type},
				$o->{Exchange},
				$o->{QuantityRemaining},
				$o->{Price},
				$o->{Quantity},
				$o->{QuantityBaseTraded};
		}
		next;
	    } elsif ($a =~ /^getorderbook/) {
		my @markets = ("DCR_BTC");
		if ($a ne "getorderbook") {
			if ($a =~ /^getorderbook=(.*)$/) {
				@markets = split(/\//,$1);
			}
		}
		foreach my $m (@markets) {
			status("BleuTrade $m orderbook");
			$ret = btcheckret("orderbook x $m",$bt->getorderbook($m,"ALL",50));
			if (!defined($ret)) {
				next;
			}
			my @buys = @{$ret->{result}->{buy}};
			my @sells = @{$ret->{result}->{sell}};
			my $i=0;
			while (defined($buys[$i]) || defined($sells[$i])) {
				my $b = $buys[$i];
				my $s = $sells[$i];
				my ($bs, $ss) = ("","");
				if (defined($b)) {
					$bs = sprintf "%14.8f %10.8f", $b->{Quantity},
				    	$b->{Rate};
				}
				if (defined($s)) {
					$ss = sprintf "%14.8f %10.8f", $s->{Quantity},
				    	$s->{Rate};
				}
					
				$i++;
				printf "%02d. %25s       %25s\n", $i, $bs, $ss;
			}
			#print Dumper($ret);
			next;
		}
	    } elsif ($a =~ /^markethistory/) {
		my @markets = ("DCR_BTC");
		if ($a ne "getmarkethistory") {
			if ($a =~ /^getmarkethistory=(.*)$/) {
				@markets = split(/\//,$1);
			}
		}
		foreach my $m (@markets) {
			status("BleuTrade $m markethistory");
			$ret = btcheckret("markethistory", $bt->getmarkethistory);
			if (!defined($ret)) {
				next;
			}
			print Dumper($ret);
		}
	    } elsif ($a eq 'getorderhistory') {
		status("BleuTrade order history");
		$ret = $bt->getorderhistory;
		print Dumper($ret);
	    } elsif ($a eq "markets") {
		status("BlueTrade Markets");
		$ret = btcheckret('markets',$bt->getmarketsummaries);
		if (!defined($ret)) {
			next;
		}
		my $ml = { };
		foreach my $m (@{$ret->{result}}) {
			if ($m->{IsActive} ne "true") {
				next;
			}
			foreach my $v (keys %{$m}) {
				my $mylen = length($m->{$v});
				if (!defined($ml->{$v})) {
					$ml->{$v} = $mylen;
					next;
				}
				if ($mylen > $ml->{$v}) {
					$ml->{$v} = $mylen;
				}
			}
		}
		printf	"%".$ml->{TimeStamp}."s ".
			"%".$ml->{MarketName}."s ".
			"%".$ml->{Ask}."s ".
			"%".$ml->{High}."s ".
			"%".$ml->{Average}."s ".
			"%".$ml->{Low}."s ".
			"%".$ml->{Bid}."s ".
			"%".$ml->{BaseVolume}."s ".
			"\n",
			"TimeStamp",
			"Name", "Ask", "High", "Average", "Low", "Bid", "BaseVolume";
		foreach my $m (@{$ret->{result}}) {
			if ($m->{IsActive} ne "true") {
				next;
			}
			if (defined($a)) {
				if ($m->{MarketName} =~ /${a}/) {
					#
				} else {
					next;
				}
			}
			printf	"%".$ml->{TimeStamp}."s ".
				"%".$ml->{MarketName}."s ".
				"%".$ml->{Ask}.".8f ".
				"%".$ml->{High}.".8f ".
				"%".$ml->{Average}.".8f ".
				"%".$ml->{Low}.".8f ".
				"%".$ml->{Bid}.".8f ".
				"%".$ml->{BaseVolume}.".8f ".
				"\n",
				$m->{TimeStamp},
				$m->{MarketName}, $m->{Ask}, $m->{High},
				$m->{Average}, $m->{Low}, $m->{Bid},
				$m->{BaseVolume};
		}
	    } elsif (defined($a)) {
		printf "Unhandled a='%s'\n", $a;
		next;
	    }
	}
}
	

sub dcrbtc {
	if (!defined($mcli->{bleutrade})) {
		$mcli->{bleutrade} = bleutrade_setup();
	}

	status("1 DCR = ? BTC");
	my $dcrbtc = $mcli->{bleutrade}->dcrbtc;
	if ($dcrbtc->{success} eq "true") {
		foreach my $m (@{$dcrbtc->{result}}) {
			foreach my $v (sort keys %{$m}) {
				if ($opt_q > 0) {
					if ($v eq "Last") {
						print $m->{$v}."\n";
					}
					next;
				}
				print $v.": ".$m->{$v}."\n";
			}
		}
	}
	#print Dumper($dcrbtc);
}

# BlueTrade Exchange
sub btexch {
	if (!defined($opt_a)) {
		print "btexch: opt_a = <undef>\n";
		return;
	}

	if (!defined($mcli->{bleutrade})) {
		$mcli->{bleutrade} = bleutrade_setup();
	}

	my $bt = $mcli->{bleutrade};
	my $btexch = $bt->getmarketsummaries;

	foreach my $pair (split(/,/,$opt_a)) {
		my ($a,$b) = split(/:/,$pair);
		if ($btexch->{success} ne "true") {
			next;
		}
		foreach my $m (@{$btexch->{result}}) {
			if ($m->{MarketName} ne "${a}_${b}") {
				next;
			}

			status("1 ${a} = ? ${b}");
			print $m->{Average}."\n";
		}
	}

	#print Dumper($dcrbtc);
}

sub btcusd {
	if (!defined($mcli->{coinbase})) {
		$mcli->{coinbase} = coinbase_setup();
	}

	status("1 BTC = ? USD");
	my $coinbase = $mcli->{coinbase};
	my ($res) = $coinbase->get_spot_price("USD");
	my $cbavg = $res->{data}->{amount};

	if (!defined($mcli->{bitstamp})) {
		$mcli->{bitstamp} = bitstamp_setup();
	}
	my $bitstamp = $mcli->{bitstamp};
	$res = $bitstamp->ticker;
	my $bid = $res->{bid};
	my $ask = $res->{ask};
	my $bsavg = ($bid+$ask)/2;

	if (!defined($mcli->{kraken})) {
		use Finance::Bank::Kraken;
		$mcli->{kraken} = kraken_setup();
	}
	my $kraken = $mcli->{kraken};
	$res = $kraken->call(Public, 'Ticker', ['pair=XBTUSD']);
	my $parsed = parse_json( $res, 'kraken' );

	my $btc = $parsed->{result}->{XXBTZUSD};
	if (!defined($btc)) {
		print "Oops, btc not found\n";
		return;
	}
	$bid = $btc->{b}[0];
	$ask = $btc->{a}[0];
	my $kravg = ($bid+$ask)/2;

	my @vals;
	if (defined($kravg) && $kravg > 0.0) {
		if ($opt_q < 1) {
			printf "Kraken   %0.3f\n", $kravg;
		}
		push @vals, $kravg;
	}
	if (defined($bsavg) && $bsavg > 0.0) {
		if ($opt_q < 1) {
			printf "Bitstamp %0.3f\n", $bsavg;
		}
		push @vals, $bsavg;
	}
	if (defined($cbavg) && $cbavg > 0.0) {
		if ($opt_q < 1) {
			printf "Coinbase %0.3f\n", $cbavg;
		}
		push @vals, $cbavg;
	}
	my $avg = 0.0;
	my $act = 0;
	foreach my $a (@vals) {
		$avg += $a;
		$act ++;
	}
	$avg = $avg/$act;
	if ($opt_q < 1) {
		print "Average  ";
	}
	printf "%0.2f",$avg;
	if ($opt_q < 1) {
		print "\n";
	}
}

sub weather_init_lines {
	my $lines = { };
	$lines->{topline} = sprintf("%14s","Hour");
	$lines->{infline} = sprintf("%14s","Temp(F)");
	$lines->{spdline} = sprintf("%14s","WindSpeed");
	$lines->{feeline} = sprintf("%14s","RealFeel");
	$lines->{humline} = sprintf("%14s","Humidity");
	$lines->{qpfline} = sprintf("%14s","Rainfall(in)");
	return $lines;
}

sub rank_length {
	my ($fname, $val) = @_;
	if (defined($stats->{lengths}->{$fname})) {
		if ($stats->{lengths}->{$fname} < length($val)) {
			$stats->{lengths}->{$fname} = length($val);
		}
	} else {
		$stats->{lengths}->{$fname} = length($val);
	}
}
sub get_length {
	my ($val) = @_;
	return $stats->{lengths}->{$val};
}

sub cull_dc {
	my ($sp) = @_;

	my $dc = $sp->{datacenter};

	if (!defined($dc)) {
		return;
	}

	$stats->{dcs}->{$dc} = 1;
}

sub hetzner_show_market_list {
	my ($parsed, $servers, $dc) = @_;
	my $scount=0;
	# XXX make this a sort, and print up to X servers
	foreach my $server ( @{$parsed} ) {
		if ($scount++ < 1 && $opt_v > 0) {
			print Dumper($server);
		}
		my $sp = $server->{product};
		if (defined($dc)) {
			if ($sp->{datacenter} ne $dc) {
				next;
			}
		} else {
			cull_dc($sp);
		}
		my $disk =  $sp->{hdd_count} * $sp->{hdd_size};
		if ($disk < $opt_D) {
			next;
		}
		foreach my $name (keys %{$servers}) {
			my $s = $servers->{$name};
			if ($s->{minmem} > $sp->{memory_size}) {
				next;
			}
			if ($s->{mincpu} > $sp->{cpu_benchmark}) {
				next;
			}
			if ($s->{mindisk} >
			    ($sp->{hdd_count} * $sp->{hdd_size})) {
				next;
			}
			if (!defined($s->{winner})) {
				$s->{winner} = $server;
				next;
			}
			my $wp = $s->{winner}->{product};
			if ($sp->{price} < $wp->{price}) {
				next;
			}
			if ($sp->{price} == $wp->{price}) {
				if ($sp->{memory_size} > $wp->{memory_size}) {
					$s->{winner} = $server;
					next;
				}
				my $wd = $wp->{hdd_count} * $wp->{hdd_size};
				if ($disk > $wd) {
					$s->{winner} = $server;
					next;
				}
				if ($sp->{cpu_benchmark} > $wp->{cpu_benchmark}) {
					$s->{winner} = $server;
					next;
				}
			}
		}
	}
	foreach my $name (keys %{$servers}) {
		my $wp = $servers->{$name}->{winner}->{product};
		if (!defined($servers->{$name}->{winner}->{product})) {
			next;
		}
		rank_length('EUR', sprintf("%0.2f", $wp->{price}));
		rank_length('name', $wp->{name});
		rank_length('myname', $name);
		rank_length('cpu', $wp->{cpu_benchmark});
		rank_length('hdcount', $wp->{hdd_count});
		rank_length('hdsize', $wp->{hdd_size});
		rank_length('hdtotal', $wp->{hdd_count} * $wp->{hdd_size});
	}
	my $eulen = get_length('EUR');
	my $namlen = get_length('name');
	my $mynamlen = get_length('myname');
	my $cpulen = get_length('cpu');
	my $hdclen = get_length('hdcount');
	my $hdslen = get_length('hdsize');
	my $hdtlen = get_length('hdtotal');
	printf "%7s  %${namlen}s %${cpulen}s    %${hdclen}s %${hdslen}s %${hdtlen}s %${eulen}s (min cpu disk   ram %-${mynamlen}s)\n",
	    "PID", "Name", "CPU", "RAM", "disk", "total", "EUR", 'name';
	foreach my $name (sort {
			my $x = $servers->{$a}->{winner}->{product};
			my $y = $servers->{$b}->{winner}->{product};
			if (!defined($x) || !defined($y)) {
				return -1;
			}
			if ($x->{price} > $y->{price}) {
				return 1;
			} elsif ($x->{price} == $y->{price}) {
				return 0;
			} else {
				return -1;
			}
		} keys %{$servers}) {
		my $wp = $servers->{$name}->{winner}->{product};
		if (!defined($wp)) {
			next;
		}
		printf "%7s. %${namlen}s %${cpulen}d %3d %${hdclen}dx%${hdslen}d=%${hdtlen}d %${eulen}.2f (%5d %5d %6d %-${mynamlen}s)\n", $wp->{id}, $wp->{name},
		    $wp->{cpu_benchmark},
		    $wp->{memory_size}, $wp->{hdd_count}, $wp->{hdd_size},
		    $wp->{hdd_count} * $wp->{hdd_size},
		    $wp->{price},
		    $servers->{$name}->{mincpu},
		    $servers->{$name}->{mindisk},
		    $servers->{$name}->{minmem},
		    $name;
	}
}

sub add_str_list {
	my ($str,$item,$sep)=@_;
	if (!defined($str)) {
		return $item;
	}
	if (length($str) == 0) {
		return $item;
	}
	if (!defined($sep)) {
		$sep = ",";
	}
	return $str.$sep.$item;
}

1;

package Hetzner::Servers;

use strict;
use warnings;

sub new {
	my ($class, $parent) = @_;

	my $me = { };

	my $ret = bless $me, $class;

	$me->init();

	return $ret;

}

sub init {
	my ($servers) = @_;

	$servers->{px}->{minmem} = 48;
	$servers->{px}->{mincpu} = 5165;
	$servers->{px}->{mindisk} = 4096;

	$servers->{'pxCPU+'}->{minmem} = 48;
	$servers->{'pxCPU+'}->{mincpu} = 5683;
	$servers->{'pxCPU+'}->{mindisk} = 4096;

	$servers->{'pxCPU12k'}->{minmem} = 48;
	$servers->{'pxCPU12k'}->{mincpu} = 12287;
	$servers->{'pxCPU12k'}->{mindisk} = 4096;

	$servers->{'pxD+'}->{minmem} = 48;
	$servers->{'pxD+'}->{mincpu} = 5681;
	$servers->{'pxD+'}->{mindisk} = 4097;

	$servers->{'pxD6k'}->{minmem} = 48;
	$servers->{'pxD6k'}->{mincpu} = 5681;
	$servers->{'pxD6k'}->{mindisk} = 6143;

	$servers->{'pxD8k'}->{minmem} = 48;
	$servers->{'pxD8k'}->{mincpu} = 5681;
	$servers->{'pxD8k'}->{mindisk} = 8191;

	$servers->{'pxM+'}->{minmem} = 49;
	$servers->{'pxM+'}->{mincpu} = 5681;
	$servers->{'pxM+'}->{mindisk} = 4096;

	$servers->{st8}->{minmem} = 1;
	$servers->{st8}->{mincpu} = 1;
	$servers->{st8}->{mindisk} = 8191;

	$servers->{st12}->{minmem} = 1;
	$servers->{st12}->{mincpu} = 1;
	$servers->{st12}->{mindisk} = 12287;

	$servers->{st16}->{minmem} = 1;
	$servers->{st16}->{mincpu} = 1;
	$servers->{st16}->{mindisk} = 16383;

	$servers->{st24}->{minmem} = 1;
	$servers->{st24}->{mincpu} = 1;
	$servers->{st24}->{mindisk} = 24575;

	$servers->{st32}->{minmem} = 1;
	$servers->{st32}->{mincpu} = 1;
	$servers->{st32}->{mindisk} = 32767;

	$servers->{mem64}->{minmem} = 63;
	$servers->{mem64}->{mincpu} = 1;
	$servers->{mem64}->{mindisk} = 0;

	$servers->{mem96}->{minmem} = 95;
	$servers->{mem96}->{mincpu} = 1;
	$servers->{mem96}->{mindisk} = 0;

	$servers->{mem128}->{minmem} = 127;
	$servers->{mem128}->{mincpu} = 1;
	$servers->{mem128}->{mindisk} = 0;

	$servers->{mem160}->{minmem} = 159;
	$servers->{mem160}->{mincpu} = 1;
	$servers->{mem160}->{mindisk} = 0;

	$servers->{mem192}->{minmem} = 191;
	$servers->{mem192}->{mincpu} = 1;
	$servers->{mem192}->{mindisk} = 0;

	$servers->{mem224}->{minmem} = 223;
	$servers->{mem224}->{mincpu} = 1;
	$servers->{mem224}->{mindisk} = 0;

	$servers->{mem256}->{minmem} = 255;
	$servers->{mem256}->{mincpu} = 1;
	$servers->{mem256}->{mindisk} = 0;

	$servers->{cpu6k}->{minmem} = 1;
	$servers->{cpu6k}->{mincpu} = 6143;
	$servers->{cpu6k}->{mindisk} = 0;

	$servers->{cpu12k}->{minmem} = 1;
	$servers->{cpu12k}->{mincpu} = 12287;
	$servers->{cpu12k}->{mindisk} = 0;

	$servers->{cpu16k}->{minmem} = 1;
	$servers->{cpu16k}->{mincpu} = 16383;
	$servers->{cpu16k}->{mindisk} = 0;

	$servers->{cpu24k}->{minmem} = 1;
	$servers->{cpu24k}->{mincpu} = 24575;
	$servers->{cpu24k}->{mindisk} = 0;

	if (defined($opt_D)||defined($opt_C)||defined($opt_M)) {
		$servers->{cli}->{minmem} = 1;
		$servers->{cli}->{mincpu} = 1;
		$servers->{cli}->{mindisk} = 1;
		if (defined($opt_D)) {
			$servers->{cli}->{mindisk} = $opt_D;
		}
		if (defined($opt_M)) {
			$servers->{cli}->{minmem} = $opt_M;
		}
		if (defined($opt_C)) {
			$servers->{cli}->{mincpu} = $opt_C;
		}
	}
}

